{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/advanced-kotlin-어노테이션과-리플렉션/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/컴퓨터-구조론-이론-메모리와-캐시-메모리/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 메모리와 캐시 메모리","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-CPU의-성능-향상-기법/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] CPU의 성능 향상 기법","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-코틀린을-더-알아보자/"},"timeToRead":11,"frontmatter":{"title":"[코틀린 고급] 코틀린을 더 알아보자!","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-CPU의-작동-원리/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] CPU의 작동 원리","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-어노테이션과-리플렉션/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 고급] 어노테이션과 리플렉션","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-연산자-오버로딩과-Kotlin-DSL/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 연산자 오버로딩과 Kotlin DSL","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-명령어/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] 명령어","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-데이터/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 데이터","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":6},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":6},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"c8729d63-02ef-58f0-88f0-bf8fa380a1c0","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz41SMUtCURh9P6I9GoTGfkCbtISDEIig7wml2FIimaE0pLVUBkY22NSSSqmEkZHobKavMM0wyBoawppe8YS83/fFe5qKk4cznHu55zuXey5HKoAIkAihy9HADWjsCwT8R3cLEVQMmxlRSISDM3pLJihtwMwSyV+qATq23oihpWJuI0xck7CZa7nHwMdR9ZgRVSrl2lOt/FAmIkmS6s/19FU6m8sOJeMPkTP++OqebW9MsZeMMh4Yb+FNgil5ngzsBZwrTp1eZxbMlnmLa80V3A/2k3+RPnyH74sLofVCVUkCxsBoMlrtVv2c3r/l185oeYG32W2aSY3H63E4Hc3PpmJG9d55b2p6uza+S/wy3OWVdygUbhuNRjQWDR+Fi8ViJBpJXaRip7FSqSSKoizLPTOc5CXDPa3e4M4lxRPU+lb7Axy9qoHSkACgUw9jDBEZYx09WBjXP60SVY74Sf4AtOgKavup5M4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png\"\n        srcset=\"/static/619e6175d83cd70c239721219e3cbc91/6f3f2/banner.png 256w,\n/static/619e6175d83cd70c239721219e3cbc91/01e7c/banner.png 512w,\n/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png 1024w,\n/static/619e6175d83cd70c239721219e3cbc91/c1b63/banner.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>해당 포스팅은 인프런의 <a href=\"https://inf.run/GZfvz\">코틀린 고급편</a> 강의를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>코틀린의 어노테이션</h2>\n<p>이번에는 어노테이션에 대해 알아보자. 어노테이션의 사전적 정의를 찾아보면 다음과 같다.</p>\n<blockquote>\n<p>A note added to a text, book, drawing, etc. as comment or explanation</p>\n</blockquote>\n<p>해석해 보면 어노테이션이란 “추가적인 설명 혹은 의견을 달기 위한 메모”라는 뜻이다. 자바나 코틀린에서 이야기하는 어노테이션도 이와 동일한 개념이다. 특정 코드에 어노테이션을 붙여 개발자에게 의견을 알리거나 무언가 특별한 일이 일어나도록 만들 수 있다. 이런 특별한 일은 리플렉션 기술과도 연결이 되고 단순히 어노테이션만 붙여서는 아무런 일도 발생하지 않는다.</p>\n<p>그러면 코틀린 어노테이션을 만들어보자. 만드는 방법은 매우 간단하다. 아래처럼만 하면 끝이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> Shape</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>코틀린에서 어노테이션을 만들기 위해서는 <code>annotaiton class</code>를 사용한다. 어노테이션을 만들 때는 2가지 특별한 어노테이션을 추가로 붙일 수 있다. 첫번째는 <code>@Retention</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Retention</span><span class=\"token punctuation\">(</span>AnnotationRetention<span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> Shape</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code>@Retention</code>은 우리의 Shape 어노테이션이 저장되고 유지되는 방식을 제어한다. 적용할 수 있는 값은 3가지로 다음 의미를 갖고 있다.</p>\n<ul>\n<li>SOURCE : Shape 어노테이션이 컴파일 때에만 존재한다.</li>\n<li>BINARY : Shape 어노테이션이 런타임 때도 존재하지만, 리플렉션 기술을 활용할 수는 없다.</li>\n<li>RUNTIME : Shape 어노테이션을 리플렉션 기술에 활용할 수 있다.</li>\n</ul>\n<p>코틀린에서 <code>@Retention</code>의 기본값은 RUNTIME 이기 때문에 대부분 Retention 어노테이션을 붙여주지 않아도 된다. 자바에서는 <code>BINARY</code>가 기본값이다. 다음으로는 <code>@Target</code>을 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Target</span><span class=\"token punctuation\">(</span>AnnotationTarget<span class=\"token punctuation\">.</span>CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> Shape</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code>@Target</code>은 우리의 Shape 어노테이션을 어디에 붙일지 선택할 수 있게 해준다. 예를 들어 CLASS라고 적으면 우리의 어노테이션을 클래스나 인터페이스에 붙일 수 있게 된다. 언어의 구성 요소가 다양한 만큼, AnnotationTarget의 종류는 굉장히 많고 @Target을 설정하지 않으면 거의 대부분의 구성 요소에 어노테이션을 붙일 수 있게 설정되어 있다. 또한 어노테이션은 추가적인 필드를 받을 수도 있다. 코틀린에서는 어노테이션 클래스에 생성자를 만들어 필드를 입력할 수 있게 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Shape</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> text<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">val</span> number<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">val</span> clazz<span class=\"token operator\">:</span> KClass<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>생성자에 들어갈 수 있는 타입은 다음과 같다.</p>\n<ul>\n<li><code>Int</code>나 <code>Double</code> 같은 기본 타입과 <code>String</code></li>\n<li>Enum 클래스, 다른 어노테이션, <code>KClass</code></li>\n<li>허용되는 타입의 배열</li>\n</ul>\n<p>그런데 여기서 <code>KClass</code>는 정말 생소하게 느껴질 것이다. <code>KClass</code>는 코드로 작성된 클래스의 정보를 가지고 있는 클래스를 뜻한다. 예를 들어보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>reflection\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">GoldFish</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">swim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"swimming\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같은 클래스가 있을 때 해당 클래스의 정보를 구하고 싶으면 아래와 같이 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>reflection\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> kClass <span class=\"token operator\">=</span> GoldFish<span class=\"token operator\">::</span><span class=\"token keyword\">class</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>KClass</code> 값을 얻기 위해서는 클래스에 <code>::class</code>를 붙이면 된다.</p>\n<p>이제 어노테이션을 만들었으니 사용해 보자! 어노테이션은 벌써 많이 사용해 보았지만, <code>@어노테이션</code> 문법을 이용해 어노테이션을 사용할 수 있다. 만약 여러 어노테이션을 붙이고 싶다면, <code>@[어노테이션1 어노테이션2]</code> 문법을 사용할 수도 있다. 어노테이션에 필드를 넘겨주고 싶다면, 코틀린에 있는 named argument를 활용할 수도 있고 단순히 순서대로 값을 넣어줄 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Shape</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> text<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">val</span> number<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// named argument를 사용한 방법</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span>number <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> text <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"안녕!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Hello\n\n<span class=\"token comment\">// 단순히 필드를 대입해준 방법</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"안녕!\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Hello</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약, 어노테이션 필드 중 배열이 있다면 <code>[ ]</code> 기호를 사용해 필드를 대입해 주어야 한다! 잘 사용되지는 않지만, <code>arrayOf</code>라는 함수를 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Shape</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> texts<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// [ ]를 사용한 방법</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">,</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"B\"</span></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Hello\n\n<span class=\"token comment\">// arrayOf를 사용한 방법</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span><span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"B\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Hello</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 코틀린의 어노테이션 사용법을 알아보았는데, 코틀린은 간결한 언어의 특성상 어노테이션을 붙인 위치가 애매할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">Hello</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@Shape</span> <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code>@Shape</code>은 어떤 언어 요소에 붙인 것일까?</p>\n<ul>\n<li>생성자의 파라미터 name</li>\n<li>name이라는 프로퍼티</li>\n<li>name이라는 필드</li>\n<li>name의 getter</li>\n</ul>\n<p>정말 애매하다. 이 때문에 우리는 특정 언어 요소에 어노테이션을 붙였다고 정확하게 알려주어야 할 때가 있다. 아래와 같이 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">Hello</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@get:Shape</span> <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code>@</code>와 <code>Shape</code> (어노테이션 이름) 사이에 <code>get:</code>을 추가할 수 있다. 이런 문법을 use-site target이라고 부른다. use-site target의 종류는 다음과 같다.</p>\n<ul>\n<li>property : 프로퍼티 자체</li>\n<li>field : 필드</li>\n<li>get : 프로퍼티 게터</li>\n<li>set : 프로퍼티 세터</li>\n<li>param : 생성자의 파라미터</li>\n<li>setparam : 프로퍼티 setter의 파라미터</li>\n<li>delegate : 위임 객체를 저장하는 필드</li>\n<li>receiver : 확장 함수나 확장 프로퍼티의 수신 객체</li>\n<li>file : 전체 파일</li>\n</ul>\n<p>주로 사용되는 use-site target으로는 field / get / set 정도가 있으며, 만약 여러 요소를 붙일 수 있는 어노테이션이라면 param / property / field순으로 결정된다. 그런데 만약 Target에 제한을 두었다면 그 제한이 우선순위를 가지게 된다.</p>\n<p>마지막으로 Repeatable annotation이라는 개념에 대해 살펴보자! 반복 가능한 어노테이션이란, 어노테이션을 한 언어 요소에 여러 번 붙이는 것을 말한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"circle\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"star\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Hello</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>기본적으로 어노테이션을 이렇게 반복해서 붙일 수는 없다. 반복해서 붙이려면 추가적인 별도의 작업을 해줘야 한다. Java에서는 이렇게 어노테이션을 반복해서 붙이려면 다음과 같은 코드를 작성해 주어야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// JavaShape의 배열을 가지고 있는 Container 어노테이션</span>\n<span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TYPE</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RUNTIME</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">JavaShapeContainer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">JavaShape</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TYPE</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RUNTIME</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// Repeatable 어노테이션으로 연결해 주어야 한다.</span>\n<span class=\"token annotation punctuation\">@Repeatable</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token class-name\">JavaShapeContainer</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">JavaShape</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>코틀린에서는 간단히 <code>@Repeatable</code>이란 어노테이션을 우리가 만든 @Shape에 붙여주면 된다!</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>reflection\n\n<span class=\"token annotation builtin\">@Repeatable</span>\n<span class=\"token annotation builtin\">@Target</span><span class=\"token punctuation\">(</span>AnnotationTarget<span class=\"token punctuation\">.</span>CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Shape</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> texts<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>코틀린의 리플렉션</h2>\n<p>이번에는 코틀린의 리플렉션 기능들에 대해 살펴보고 간단한 예제를 한번 해보자. 우리가 오늘 만들 예제는 다음과 같다.</p>\n<ul>\n<li>함수 <code>executeAll(obj: Any)</code>은 임의의 객체 obj를 받는다.</li>\n<li>obj가 <code>@Executable</code> 어노테이션을 갖고 있다면, 파라미터가 없고 반환 타입이 <code>Unit</code>인 함수를 모두 실행시킨다.</li>\n</ul>\n<p>리플렉션 기술을 코드에서 사용하기 위해서는 한 가지 의존성을 추가해 주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">implementation</span><span class=\"token punctuation\">(</span><span class=\"token function\">kotlin</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"reflect\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>리플렉션 API는 그렇게 어렵지 않다. 리플렉션 API는 결국 우리가 작성한 코틀린 코드를 표현하는 코드이다. 우리가 작성한 GoldFish 클래스 코드가 있으면 이 GoldFish 클래스 코드의 정보를 갖고 있는 <code>KClass&#x3C;GoldFish></code>가 있고, 여기서 <code>KClass&#x3C;T></code>가 바로 리플렉션 객체이다.</p>\n<p>kClass의 정보를 얻기 위해서는 아래와 같이 해주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> goldFishKClass <span class=\"token operator\">=</span> GoldFish<span class=\"token operator\">::</span><span class=\"token keyword\">class</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>또는 객체 인스턴스에서도 구할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> reflection <span class=\"token operator\">=</span> <span class=\"token function\">Reflection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> kClass2 <span class=\"token operator\">=</span> reflection<span class=\"token operator\">::</span><span class=\"token keyword\">class</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또는 자바처럼 <code>Class.forName</code>으로 풀 패키지명을 적어서 구할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> kClass3 <span class=\"token operator\">=</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"me.sungbin.reflection.Reflection\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>kotlin</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>반대로 <code>KClass&#x3C;T></code> 값에서 <code>Class&#x3C;T></code> 값을 얻고 싶다면, <code>.java</code>를 붙여주면 된다. 그런데 여기서 갑자기 의문이 생길 수 있다.</p>\n<ul>\n<li><code>KClass&#x3C;T></code>는 무엇이고 <code>Class&#x3C;T></code>는 무엇인가?</li>\n<li>코틀린 리플렉션과 자바 리플렉션의 차이는 무엇인가?</li>\n</ul>\n<p>정답은 간단하다. 우리가 코틀린을 사용해 코드를 작성하고 있지만, 코틀린은 결국 JVM 위에서 바이트 코드로 실행되기 때문에, 코틀린의 클래스에 대해서는 코틀린 리플렉션을 적용할 수도 있고 자바 리플렉션을 적용할 수도 있다. 둘은 상호 보완적인 관계이다. 따라서 한쪽 진영에서 지원하지 않는 기능은 다른 쪽 진영의 기능을 활용할 수 있다.</p>\n<p>예를 들어, 우리가 KClass를 만들기 위해 사용했던 <code>Class.forName()</code> 함수 자체가 자바 진영의 리플렉션 기능이다. 또 다른 예로, KClass에는 <code>inner class</code>인지 확인하는 <code>isInner</code> 기능이 있지만 inner class 라고 명시해서 적어주는 언어 특성은 코틀린에만 있기 때문에 자바 리플렉션 기능에는 <code>isInner()</code>라는 함수가 없다.</p>\n<p>그럼 이제 KClass 의 주요 기능을 살펴보자. 코드에서 등장하는 <code>actual</code>은 코틀린 멀티플랫폼과 관련된 지시어로 <code>actual</code>이 있다면 특정 플랫폼의 코드, <code>expect</code>가 있다면 모든 플랫폼에서 사용하는 표준 인터페이스를 의미한다.</p>\n<ul>\n<li><code>qualifedName</code> : <code>simpleName</code>과 달리 패키지 경로까지 포함한 이름을 반환한다.</li>\n<li><code>members</code> / <code>constructos</code> : 클래스가 갖고 있는 함수, 프로퍼티, 생성자들을 반환하는 기능이다. 주석을 읽어보면 declared라는 단어를 확인할 수 있다. declared는 private, public을 구분하지 않고 코드에 선언된 모든 함수, 프로퍼티, 생성자를 가져온다는 의미이다. 자바의 리플렉션 API를 살펴보면 <code>getFields()</code> <code>getDeclaredFields()</code> 와 같이 declared가 붙은 메소드가 구분되어 있는데, private한 필드까지 포함해 반환하는지 여부로 구분하면 된다.</li>\n<li><code>isData</code> / <code>isInner</code> / <code>isSaled</code> : 코틀린 리플렉션 API 이기 때문에 코틀린에서 제공하는 언어 특성과 연관된 기능들이 많이 제공된다.</li>\n</ul>\n<p><code>KClass</code>와 관련해서는 알아두면 좋을 두 가지 기능이 더 있다. 첫 번째는 <code>KClass.cast()</code> 함수이다! 이 함수는 들어오는 임의의 인스턴스를 KClass 타입으로 캐스팅해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">castToGoldFish</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> GoldFish <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> GoldFish<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">cast</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>두 번째는 <code>KClass</code>에서 <code>KType</code>을 얻어내는 방법이다. <code>KType</code>은 타입을 표현한 리플렉션 인터페이스로 어떤 타입이 null인지 아닌지, <code>out</code> / <code>in</code>과 같은 타입 변성에 붙어 있는지 정보를 갖고 있다. 이 함수는 <code>KClass.createType()</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> goldFishType <span class=\"token operator\">=</span> GoldFish<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">createType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code>KClass KType</code> 외에도 언어의 주요 구성요소인 <code>KParameter</code> / <code>KTypeParameter</code>도 존재한다. 또한 무언가 호출할 수 있다는 의미를 담고 있는 KCallable 인터페이스도 존재한다. 호출할 수 있다는 의미가 무엇일까? 함수나 프로퍼티처럼 무언가 실행시킬 수 있다는 의미이다! 이 둘은 각각 <code>KFunction</code> <code>KProperty</code>로 표현된다.</p>\n<p><code>KCallable</code>의 주요한 함수로는 <code>call</code>과 <code>callBy</code>가 존재한다.</p>\n<ul>\n<li><code>call</code>: 가변인자로 파라미터를 받는다. 파라미터의 개수나 타입이 잘못되면 에러가 발생할 수 있다.</li>\n<li><code>callBy</code>: <code>KParameter</code>를 key로 하는 <code>Map</code>을 받아 함수를 호출한다. <code>call</code>과 마찬가지로 파라미터의 개수나 타입이 잘못되면 에러가 발생할 수 있다.</li>\n</ul>\n<p>또한, <code>KCallable</code>에서 parameters 필드는 주요하게 봐야 한다. 만약 멤버함수 이거나 확장함수일 경우, parameters의 첫 번째 파라미터로는 함수가 위치한 클래스를 갖고 있다. 아래의 코드가 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>reflection\n\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span>texts <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"B\"</span></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation builtin\">@Shape</span><span class=\"token punctuation\">(</span>texts <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"C\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"D\"</span></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token function\">GoldFish</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">swim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"swimming\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 클래스 swim 함수는 파라미터가 비어있지만 아래의 코드를 실행해서 확인해보면 swim이라는 함수에 GoldFish라는 파라미터를 갖고 있는 것처럼 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\">GoldFish<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>name <span class=\"token operator\">==</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"swim\"</span></span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">first</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>parameters</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 외에도 어노테이션을 붙일 수 있다는 의미인 <code>KAnnotatedElement</code>, <code>GoldFish</code>라고 적힌 글자가 <code>GoldFish</code> 클래스인지 <code>&#x3C;GoldFish></code> 타입 파라미터인지 구별하는 <code>KClassifier</code>등이 존재한다. 그러면 이것을 응용해서 한번 예제를 구현해보자. 구현한 결과는 제공할테니 독자가 먼저 스스로 풀기를 바란다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>reflection\n\n<span class=\"token annotation builtin\">@Target</span><span class=\"token punctuation\">(</span>AnnotationTarget<span class=\"token punctuation\">.</span>CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">annotation</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Executable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Executable</span>\n<span class=\"token keyword\">class</span> Reflection <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"a입니다.\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"b입니다.\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">executeAll</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> kClass <span class=\"token operator\">=</span> obj<span class=\"token operator\">::</span><span class=\"token keyword\">class</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>kClass<span class=\"token punctuation\">.</span>hasAnnotation<span class=\"token operator\">&lt;</span>Executable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">val</span> callableFunctions <span class=\"token operator\">=</span> kClass<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span>filterIsInstance<span class=\"token operator\">&lt;</span>KFunction<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>returnType <span class=\"token operator\">==</span> Unit<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">createType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>parameters<span class=\"token punctuation\">.</span>size <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> it<span class=\"token punctuation\">.</span>parameters<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> kClass<span class=\"token punctuation\">.</span><span class=\"token function\">createType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n    callableFunctions<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span>\n        it<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","fields":{"slug":"/advanced-kotlin-어노테이션과-리플렉션/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 고급] 어노테이션과 리플렉션","tags":["kotlin"],"date":"2026-02-21T19:19:27.000Z","image":{"publicURL":"/static/619e6175d83cd70c239721219e3cbc91/banner.png"},"series":"코틀린 고급"}}},"pageContext":{"id":"c8729d63-02ef-58f0-88f0-bf8fa380a1c0"}},
    "staticQueryHashes": ["2580406332","3810308631"]}