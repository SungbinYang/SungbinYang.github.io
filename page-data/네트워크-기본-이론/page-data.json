{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/네트워크-기본-이론/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/HTTP-서버-만들기/"},"timeToRead":25,"frontmatter":{"title":"[자바 고급2] HTTP 서버 만들기","series":"자바 고급2"}},{"fields":{"slug":"/HTTP-기본-이론/"},"timeToRead":5,"frontmatter":{"title":"[자바 고급2] HTTP 기본 이론","series":"자바 고급2"}},{"fields":{"slug":"/채팅-프로그램/"},"timeToRead":21,"frontmatter":{"title":"[자바 고급2] 채팅 프로그램","series":"자바 고급2"}},{"fields":{"slug":"/네트워크-프로그램2/"},"timeToRead":16,"frontmatter":{"title":"[자바 고급2] 네트워크 프로그램2","series":"자바 고급2"}},{"fields":{"slug":"/네트워크-프로그램1/"},"timeToRead":18,"frontmatter":{"title":"[자바 고급2] 네트워크 프로그램1","series":"자바 고급2"}},{"fields":{"slug":"/네트워크-기본-이론/"},"timeToRead":14,"frontmatter":{"title":"[자바 고급2] 네트워크 - 기본 이론","series":"자바 고급2"}},{"fields":{"slug":"/File-Files/"},"timeToRead":8,"frontmatter":{"title":"[자바 고급2] File, Files","series":"자바 고급2"}},{"fields":{"slug":"/IO-활용/"},"timeToRead":9,"frontmatter":{"title":"[자바 고급2] I/O 활용","series":"자바 고급2"}},{"fields":{"slug":"/IO-기본2/"},"timeToRead":6,"frontmatter":{"title":"[자바 고급2] I/O 기본2","series":"자바 고급2"}},{"fields":{"slug":"/IO-기본1/"},"timeToRead":15,"frontmatter":{"title":"[자바 고급2] I/O 기본1","series":"자바 고급2"}},{"fields":{"slug":"/문자-인코딩/"},"timeToRead":10,"frontmatter":{"title":"[자바 고급2] 문자 인코딩","series":"자바 고급2"}},{"fields":{"slug":"/스레드-풀과-Executor-프레임워크2/"},"timeToRead":14,"frontmatter":{"title":"[자바 고급1] 스레드 풀과 Executor 프레임워크2","series":"자바 고급1"}},{"fields":{"slug":"/스레드-풀과-Executor-프레임워크1/"},"timeToRead":20,"frontmatter":{"title":"[자바 고급1] 스레드 풀과 Executor 프레임워크1","series":"자바 고급1"}},{"fields":{"slug":"/동시성-컬렉션/"},"timeToRead":9,"frontmatter":{"title":"[자바 고급1] 동시성 컬렉션","series":"자바 고급1"}},{"fields":{"slug":"/CAS-동기화와-원자적-연산/"},"timeToRead":14,"frontmatter":{"title":"[자바 고급1] CAS - 동기화와 원자적 연산","series":"자바 고급1"}},{"fields":{"slug":"/생산자-소비자-문제2/"},"timeToRead":11,"frontmatter":{"title":"[자바 고급1] 생산자 소비자 문제2","series":"자바 고급1"}},{"fields":{"slug":"/생산자-소비자-문제1/"},"timeToRead":14,"frontmatter":{"title":"[자바 고급1] 생산자 소비자 문제1","series":"자바 고급1"}},{"fields":{"slug":"/고급-동기화-concurrent-Lock/"},"timeToRead":11,"frontmatter":{"title":"[자바 고급1] 고급 동기화 - concurrent.Lock","series":"자바 고급1"}},{"fields":{"slug":"/동기화-synchronized/"},"timeToRead":7,"frontmatter":{"title":"[자바 고급1] 동기화 - synchronized","series":"자바 고급1"}},{"fields":{"slug":"/메모리-가시성/"},"timeToRead":5,"frontmatter":{"title":"[자바 고급1] 메모리 가시성","series":"자바 고급1"}},{"fields":{"slug":"/스레드-제어와-생명주기2/"},"timeToRead":11,"frontmatter":{"title":"[자바 고급1] 스레드 제어와 생명주기2","series":"자바 고급1"}},{"fields":{"slug":"/스레드-제어와-생명주기1/"},"timeToRead":12,"frontmatter":{"title":"[자바 고급1] 스레드 제어와 생명주기1","series":"자바 고급1"}},{"fields":{"slug":"/스레드-생성과-실행/"},"timeToRead":8,"frontmatter":{"title":"[자바 고급1] 스레드 생성과 실행","series":"자바 고급1"}},{"fields":{"slug":"/프로세스와-스레드-소개/"},"timeToRead":9,"frontmatter":{"title":"[자바 고급1] 프로세스와 스레드 소개","series":"자바 고급1"}},{"fields":{"slug":"/컬렉션-프레임워크-순회-정렬-전체-정리/"},"timeToRead":16,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - 순회, 정렬, 전체 정리","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-Map-Stack-Queue/"},"timeToRead":7,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - Map, Stack, Queue","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-Set/"},"timeToRead":6,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - Set","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-HashSet/"},"timeToRead":11,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - HashSet","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-Hash/"},"timeToRead":6,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - Hash","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-List/"},"timeToRead":17,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - List","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-LinkedList/"},"timeToRead":14,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - LinkedList","series":"자바 중급2"}},{"fields":{"slug":"/컬렉션-프레임워크-ArrayList/"},"timeToRead":15,"frontmatter":{"title":"[자바 중급2] 컬렉션 프레임워크 - ArrayList","series":"자바 중급2"}},{"fields":{"slug":"/제네릭2/"},"timeToRead":14,"frontmatter":{"title":"[자바 중급2] 제네릭2","series":"자바 중급2"}},{"fields":{"slug":"/제네릭1/"},"timeToRead":9,"frontmatter":{"title":"[자바 중급2] 제네릭1","series":"자바 중급2"}},{"fields":{"slug":"/예외처리2-실습/"},"timeToRead":17,"frontmatter":{"title":"[자바 중급1] 예외처리2 - 실습","series":"자바 중급1"}},{"fields":{"slug":"/예외처리1-이론/"},"timeToRead":12,"frontmatter":{"title":"[자바 중급1] 예외처리1 - 이론","series":"자바 중급1"}},{"fields":{"slug":"/중첩-클래스-내부-클래스2/"},"timeToRead":9,"frontmatter":{"title":"[자바 중급1] 중첩 클래스, 내부 클래스2","series":"자바 중급1"}},{"fields":{"slug":"/중첩-클래스-내부-클래스1/"},"timeToRead":11,"frontmatter":{"title":"[자바 중급1] 중첩 클래스, 내부 클래스1","series":"자바 중급1"}},{"fields":{"slug":"/날짜와-시간/"},"timeToRead":24,"frontmatter":{"title":"[자바 중급1] 날짜와 시간","series":"자바 중급1"}},{"fields":{"slug":"/열거형-enum/"},"timeToRead":7,"frontmatter":{"title":"[자바 중급1] 열거형-enum","series":"자바 중급1"}},{"fields":{"slug":"/래퍼-Class-클래스/"},"timeToRead":11,"frontmatter":{"title":"[자바 중급1] 래퍼, Class 클래스","series":"자바 중급1"}},{"fields":{"slug":"/String-클래스/"},"timeToRead":10,"frontmatter":{"title":"[자바 중급1] String 클래스","series":"자바 중급1"}},{"fields":{"slug":"/불변-객체/"},"timeToRead":7,"frontmatter":{"title":"[자바 중급1] 불변 객체","series":"자바 중급1"}},{"fields":{"slug":"/Object-클래스/"},"timeToRead":10,"frontmatter":{"title":"[자바 중급1] Object 클래스","series":"자바 중급1"}},{"fields":{"slug":"/다형성과-설계/"},"timeToRead":5,"frontmatter":{"title":"[자바 기본] 다형성과 설계","series":"자바 기본"}},{"fields":{"slug":"/다형성2/"},"timeToRead":10,"frontmatter":{"title":"[자바 기본] 다형성2","series":"자바 기본"}},{"fields":{"slug":"/다형성1/"},"timeToRead":8,"frontmatter":{"title":"[자바 기본] 다형성1","series":"자바 기본"}},{"fields":{"slug":"/상속/"},"timeToRead":7,"frontmatter":{"title":"[자바 기본] 상속","series":"자바 기본"}},{"fields":{"slug":"/final/"},"timeToRead":4,"frontmatter":{"title":"[자바 기본] final","series":"자바 기본"}},{"fields":{"slug":"/자바-메모리-구조와-static/"},"timeToRead":10,"frontmatter":{"title":"[자바 기본] 자바 메모리 구조와 static","series":"자바 기본"}},{"fields":{"slug":"/접근-제어자/"},"timeToRead":5,"frontmatter":{"title":"[자바 기본] 접근 제어자","series":"자바 기본"}},{"fields":{"slug":"/패키지/"},"timeToRead":6,"frontmatter":{"title":"[자바 기본] 패키지","series":"자바 기본"}},{"fields":{"slug":"/생성자/"},"timeToRead":6,"frontmatter":{"title":"[자바 기본] 생성자","series":"자바 기본"}},{"fields":{"slug":"/객체-지향-프로그래밍/"},"timeToRead":6,"frontmatter":{"title":"[자바 기본] 객체 지향 프로그래밍","series":"자바 기본"}},{"fields":{"slug":"/기본형과-참조형/"},"timeToRead":8,"frontmatter":{"title":"[자바 기본] 기본형과 참조형","series":"자바 기본"}},{"fields":{"slug":"/클래스와-데이터/"},"timeToRead":6,"frontmatter":{"title":"[자바 기본] 클래스와 데이터","series":"자바 기본"}},{"fields":{"slug":"/99클럽-day10/"},"timeToRead":2,"frontmatter":{"title":"[99클럽] 면접반 10일차","series":"면접"}},{"fields":{"slug":"/99클럽-day9/"},"timeToRead":1,"frontmatter":{"title":"[99클럽] 면접반 9일차","series":"면접"}},{"fields":{"slug":"/메서드/"},"timeToRead":8,"frontmatter":{"title":"[자바 입문] 메서드","series":"자바 입문"}},{"fields":{"slug":"/배열/"},"timeToRead":7,"frontmatter":{"title":"[자바 입문] 배열","series":"자바 입문"}},{"fields":{"slug":"/훈련/"},"timeToRead":3,"frontmatter":{"title":"[자바 입문] 훈련","series":"자바 입문"}},{"fields":{"slug":"/스코프-형변환/"},"timeToRead":5,"frontmatter":{"title":"[자바 입문] 스코프, 형변환","series":"자바 입문"}},{"fields":{"slug":"/반복문/"},"timeToRead":6,"frontmatter":{"title":"[자바 입문] 반복문","series":"자바 입문"}},{"fields":{"slug":"/조건문/"},"timeToRead":7,"frontmatter":{"title":"[자바 입문] 조건문","series":"자바 입문"}},{"fields":{"slug":"/99클럽-day8/"},"timeToRead":1,"frontmatter":{"title":"[99클럽] 면접반 8일차","series":"면접"}},{"fields":{"slug":"/책-관리-예제-백엔드-개발/"},"timeToRead":6,"frontmatter":{"title":"[스프링 입문] 책 관리 예제 - 백엔드 개발","series":"스프링"}},{"fields":{"slug":"/연산자/"},"timeToRead":6,"frontmatter":{"title":"[자바 입문] 연산자","series":"자바 입문"}},{"fields":{"slug":"/99클럽-day7/"},"timeToRead":1,"frontmatter":{"title":"[99클럽] 면접반 7일차","series":"면접"}},{"fields":{"slug":"/변수/"},"timeToRead":8,"frontmatter":{"title":"[자바 입문] 변수","series":"자바 입문"}},{"fields":{"slug":"/99클럽-day6/"},"timeToRead":1,"frontmatter":{"title":"[99클럽] 면접반 6일차","series":"면접"}},{"fields":{"slug":"/스프링-웹-개발-기초/"},"timeToRead":2,"frontmatter":{"title":"[스프링 입문] 스프링 웹 개발 기초","series":"스프링"}},{"fields":{"slug":"/프로젝트-환경설정/"},"timeToRead":5,"frontmatter":{"title":"[스프링 입문] 프로젝트 환경 설정","series":"스프링"}},{"fields":{"slug":"/Hello-World/"},"timeToRead":6,"frontmatter":{"title":"[자바 입문] Hello World","series":"자바 입문"}},{"fields":{"slug":"/99클럽-day5/"},"timeToRead":2,"frontmatter":{"title":"[99클럽] 면접반 5일차","series":"면접"}},{"fields":{"slug":"/99클럽-day4/"},"timeToRead":1,"frontmatter":{"title":"[99클럽] 면접반 4일차","series":"면접"}},{"fields":{"slug":"/Multi-Modules-프로젝트/"},"timeToRead":12,"frontmatter":{"title":"[Gradle] Multi Modules 프로젝트","series":"gradle"}},{"fields":{"slug":"/99클럽-day3/"},"timeToRead":3,"frontmatter":{"title":"[99클럽] 면접반 3일차","series":"면접"}},{"fields":{"slug":"/Core-Type에-대한-이해/"},"timeToRead":7,"frontmatter":{"title":"[Gradle] Core Type에 대한 이해","series":"gradle"}},{"fields":{"slug":"/99클럽-day2/"},"timeToRead":2,"frontmatter":{"title":"[99클럽] 면접반 2일차","series":"면접"}},{"fields":{"slug":"/Groovy-언어의-기본/"},"timeToRead":8,"frontmatter":{"title":"[Gradle] Groovy 언어의 기본","series":"gradle"}},{"fields":{"slug":"/99클럽-day1/"},"timeToRead":6,"frontmatter":{"title":"[99클럽] 면접반 1일차","series":"면접"}},{"fields":{"slug":"/Gradle-기본/"},"timeToRead":9,"frontmatter":{"title":"[Gradle] Gradle 기본","series":"gradle"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":4,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/IntelliJ-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 플러그인","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-Git-Github/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ IDEA] Git & Github","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ IDEA] 디버깅","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-리팩토링/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 리팩토링","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-자동완성/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 자동완성","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-검색/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 검색","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-포커스/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 포커스","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-코드-Edit/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ IDEA] 코드 Edit","series":"인텔리제이"}},{"fields":{"slug":"/IntelliJ-소개/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ IDEA] 소개","series":"인텔리제이"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않습니다/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"gradle","totalCount":5},{"fieldValue":"면접","totalCount":10},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"스프링","totalCount":3},{"fieldValue":"인텔리제이","totalCount":9},{"fieldValue":"일상","totalCount":1},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"자바 고급1","totalCount":13},{"fieldValue":"자바 고급2","totalCount":11},{"fieldValue":"자바 기본","totalCount":12},{"fieldValue":"자바 입문","totalCount":9},{"fieldValue":"자바 중급1","totalCount":10},{"fieldValue":"자바 중급2","totalCount":10},{"fieldValue":"트러블 슈팅","totalCount":1}]},"markdownRemark":{"id":"aee9a7ea-9149-5a7c-a8fd-99559d04a418","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApUlEQVQoz6WRPQvCQAyG+///R6GKm6AndhIcrNaiXVzEaqVaPym9Xs67XuIgiEvFw2whPDxJXof+KOf7uD4cUWtLGJGIHpMA2PDdWpgBqRyNOfMVkTHmV/ilSW7QjfPF+hRnpVC1hVkb3Nxla54NVpczVw1bN8Co9TbJw7QIdsX+Wtk9DHklXU+3O6bXl66HIG1gIQTzIVrCNJSzCJWyzLnp0A/4CfW+SjF6WKSqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"배너 이미지\"\n        title=\"배너 이미지\"\n        src=\"/static/3189e9c0404650ccc6c5ffc998bc8717/2bef9/banner.png\"\n        srcset=\"/static/3189e9c0404650ccc6c5ffc998bc8717/6f3f2/banner.png 256w,\n/static/3189e9c0404650ccc6c5ffc998bc8717/01e7c/banner.png 512w,\n/static/3189e9c0404650ccc6c5ffc998bc8717/2bef9/banner.png 1024w,\n/static/3189e9c0404650ccc6c5ffc998bc8717/71c1d/banner.png 1536w,\n/static/3189e9c0404650ccc6c5ffc998bc8717/e8950/banner.png 2000w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>해당 블로그 글은 <a href=\"https://inf.run/vskmA\">영한님의 인프런 강의</a>를 바탕으로 쓰여진 글입니다.</p>\n</blockquote>\n<h2>클라이언트와 서버</h2>\n<p>네트워크에서는 클라이언트와 서버라는 단어가 자주 등장한다. 그런데 클라이언트와 서버는 네트워크나 컴퓨터에서만 사용되는 용어가 아니라 넓은 범위에서 일반적으로 사용되는 용어이다.</p>\n<h3>클라이언트-서버 개념의 기본 이해</h3>\n<ul>\n<li><strong>클라이언트</strong>: 클라이언트는 서비스를 요청하는 쪽이다. 마치 식당에서 음식을 주문하는 손님처럼, 클라이언트는 어떤 정보를 얻거나 작업을 처리해달라고 요청하는 역할을 한다.</li>\n<li><strong>서버</strong>: 서버는 클라이언트의 요청을 받아들이고, 그 요청에 맞게 서비스를 제공하는 쪽이다. 식당에서 음식을 준비해서 손님에게 가져다주는 주방이나 웨이터가 서버의 역할을 한다.</li>\n</ul>\n<p><strong>클라이언트</strong>는 서비스를 요청하는 쪽이며, <strong>서버</strong>는 그 요청을 받아 서비스를 제공하는 쪽이다. 이 관계는 일상 생활에서 매우 흔하게 나타나며, 다양한 상황에서 적용될 수 있다. 이 두 가지가 함께 작동하면, 클라이언트가 요청을 보내고 서버가 그 요청을 처리해서 응답을 돌려주는 구조가 만들어진다. 이를 <strong>클라이언트-서버 모델</strong>이라고 부른다.</p>\n<h3>객채와 클라이언트-서버 관계</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.79687500000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAz0lEQVQoz31RywqEQAybTxDfL8RRRBDxplfP+v//kyWFSndY95ChGZM2Tl2apsiyTGBry8uyRFEUD948rB2P8FIRxzGmacJ1XTjPE8dx4L5vNE2DJEl++hwJBVVVoa5rqZmIIG/bVlKpibXed1335aPG5XkuZNs2EQ3DgL7vRcRvTBJFkaRlQ3KCHu895nnGuq7CqX8SKtiI6ZQzwbIskkbvOZg6TaY+SWjfTKHvw4lssu87xnEUrkt5gws3G26ZsL/8T/8kDLdr8TbIeuyWP7WZzNMlomQmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/f0f259870c4758ccee990a2706ceb607/31198/01.png\"\n        srcset=\"/static/f0f259870c4758ccee990a2706ceb607/6f3f2/01.png 256w,\n/static/f0f259870c4758ccee990a2706ceb607/01e7c/01.png 512w,\n/static/f0f259870c4758ccee990a2706ceb607/31198/01.png 694w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><code>Main.java</code> 파일에서 <code>Service.java</code>의 특정 메서드를 호출한다. 그것이 바로 요청이다. 그리고 <code>Service.java</code>에서 특정 로직을 수행하고 결과 값이 있다면 해당 결과 값을 응답으로 내려준다. 여기서 <code>Main.java</code>가 클라이언트이고 <code>Service.java</code>가 서버이다.</p>\n<blockquote>\n<p>✅ 참고</p>\n<p>참고로 여기서 응답이라는 의미는 단순히 결과 값을 반환하는 것을 넘어서 요청한 서비스를 수행한 것 자체를 의미한다. 쉽게 이야기해서 반환 값이 없어도, 클라이언트가 호출한 메서드를 서버가 수행한 것을 의미한다. (반환 타입이 void여도 서버라고 할 수 있다.)</p>\n</blockquote>\n<h3>네트워크와 클라이언트-서버</h3>\n<p>네트워크는 여러 대의 컴퓨터가 서로 연결되어 데이터를 주고받을 수 있는 환경을 의미한다. 인터넷이 대표적인 네트워크이다. 여기서도 클라이언트-서버 모델이 중요한 역할을 한다. 즉, 우리가 스마트폰이나 PC로 네이버 웹페이지를 요청하면 요총 url에 따라 서버에서 url을 확인하고 html파일을 응답으로 내려주는 것처럼 클라이언트 서버 관계는 네트워크에서 많이 사용된다.</p>\n<h3>클라이언트와 서버가 동시에 될 수도 있다.</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.40625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz22Sy6qDQBBE/QHxEZ/xiQaMqFnoQgQXmv//pw6nLxPkkkU5zFRXdc20VhiGEgSBsN5uN3EcR+H7vq6GY3VdV888z/vWXPXAYgMwK4pCpmmSYRikaRpdoyj6Crquk9frJW3byjiOUlWV6owHsJIkURFE3/dyHIfM86zG7/dbsixTLk1T2bZN9n3XOjhMSUuzOI7/Et7vd3k8Hto1z3MV27athXAkfT6fUpalmsJxdXg0cCSHJ9jXEHBY17V2g2SPIYk4p4Z6kphmcIDra0I+PC4wb4X4PE81JAkcyWlCs3VdZVkWTQpHjdFa1wmZiQGu93+CZni8O8a/tNYvkfmFrr+MwdX4yhnDD8ZW0NJjAwq2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/06cc4e8256444053ac1d291dd2c4d068/31198/02.png\"\n        srcset=\"/static/06cc4e8256444053ac1d291dd2c4d068/6f3f2/02.png 256w,\n/static/06cc4e8256444053ac1d291dd2c4d068/01e7c/02.png 512w,\n/static/06cc4e8256444053ac1d291dd2c4d068/31198/02.png 694w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>만약 위와 같이 <code>Main.java</code>가 <code>Service.java</code>의 메서드를 호출하는데 해당 메서드가 <code>Repository.java</code>의 메서드를 호출할 수 있다. 이럴 때 <code>Service.java</code>는 클라이언트인 동시에 서버인 셈이다. 이렇게 서버와 클라이언트가 동시에 될 수 있다.</p>\n<h2>인터넷 통신</h2>\n<p>만약 근거리에 PC를 통신한다고 한다면 케이블로 두 컴퓨터를 연결하여 통신을 해도 될 것이다. 필자는 학부생때 아두이노와 pc와 통신을 해본 경험이 있는데 이게 바로 케이블 통신을 한 것이다. 하지만 PC가 많아지고 내 PC로 미국의 친구와 채팅을 한다고 해보자. 그러면 우리는 메신저 창에 메세지를 입력하고 전송을 할 것이다. 그러면 그 메세지가 케이블과 허브, 라우터등 수 많은 노드들을 지나갈 것이다. 이렇게 복잡한 노드의 환경을 인터넷 환경이라고 한다. 그러면 인터넷은 어떻게 내가 보낸 메세지를 미국의 친구한테 잘 전달할 수 있을까? 어떻게 식별해서 전송하는지 알아보자.</p>\n<h2>IP(인터넷 프로토콜)</h2>\n<p>이렇게 복잡한 인터넷 망에서 어디로 보내야 하는지 정확히 알려주는 것이 바로 IP다. IP는 네트워크 계층중 L3계층의 인터넷 프로토콜 중 하나로 지정한 IP주소에 정확히 데이터를 전달하는 역할을 한다. 그리고 전달할 때 패킷이라는 통신단위로 데이터를 전달한다.</p>\n<p>패킷에는 해당 데이터와 출발지 주소 및 목적지 주소가 존재한다. 예를들어 내가 사용하는 PC의 IP가 <code>100.100.100.100</code>이라고 해보자. 그리고 미국의 친구가 <code>200.200.200.200</code>이라고 해보자. 그러면 데이터를 전송할 때 데이터에 마치 박스를 넣어서 출발지 주소와 목적지 주소를 적어서 보내는 것과 같다. 그리고 미국의 친구가 내 채팅에 답변할 때도 마찬가지로 데이터를 박스에 담아 자기의 출발지 주소인 <code>200.200.200.200</code>을 적고 목적지 주소인 <code>100.100.100.100</code>을 적는 것과 같다.</p>\n<h3>IP 프로토콜의 한계</h3>\n<ul>\n<li>비연결성\n<ul>\n<li>패킷을 받을 대상이 없거나 그 대상이 불능 상태일 때도 그냥 보낸다.</li>\n</ul>\n</li>\n<li>비신뢰성\n<ul>\n<li>중간에 패킷이 사라지는 문제 발생할 수 있다.</li>\n<li>패킷이 순서대로 안 오는 문제도 발생할 수 있다.</li>\n</ul>\n</li>\n<li>프로그램 구분\n<ul>\n<li>어떻게 정확히 미국의 친구한테 데이터를 보낼때 해당 PC의 여러 프로세스 중에 정확히 메신저 앱에 전달할까?</li>\n</ul>\n</li>\n</ul>\n<h2>TCP, UDP</h2>\n<h3>인터넷 프로토콜 4계층</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 426px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.53125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVQ4y32TSasCQQyE++6+67gv4MENBxFPboj//x/l8QVqiCLvUHQnXUkqk0zqdDo2GAx+Isuyf8+Ifr9v7Xbb0nA4tNls5k7uwndS3YXIxZ5Op85JGN1u18rlstVqNatWq36/Xq/2er3sfD7b7Xazx+Nh+/3eTqeTLRYLK5VKzgfwe72eJ06j0cjm87lLVnUq4Vf1qFp2VEwsCj0hjxio5EGgIm+TycRBAU6CeItcYvVWtFypVIoWADYtPp9Pu9/vdjwe7XK5eHF9nsj9aHm5XLrBPQIfWwBarZYXRvUvHp+taBknAQoWSECx1Wplm83G22I1vnnEKnHSN2G69Xq9AK1AzPPcJ/t+v229Xnt7jUbjg0ushuotowCl4/H4A/iazaaDAqjTgCIPm1UqFAKqoohgTmxa3u123i4D4kSReJGrPEm7BlEkoIQk2m63djgcPDlKIw8QWyRkQZGLdO2cgI9vo3+Vk7X55gH8zCIxpTg53aMPpTp/vUf7DwE0bOHrDbmnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/59d6ff591f979221c41e547186619f3b/531e1/03.png\"\n        srcset=\"/static/59d6ff591f979221c41e547186619f3b/6f3f2/03.png 256w,\n/static/59d6ff591f979221c41e547186619f3b/531e1/03.png 426w\"\n        sizes=\"(max-width: 426px) 100vw, 426px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>인터넷 프로토콜 4계층은 위와 같다.</p>\n<h3>프로토콜 계층</h3>\n<p>그러면 어떻게 우리가 채팅 프로그램으로 미국에 있는 친구한테 데이터를 보낼 수 있을까? 자세히 살펴보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAABrbnPymHAX//EABoQAAMBAAMAAAAAAAAAAAAAAAECAxEAEiL/2gAIAQEAAQUCmQs9BNVynbkz6suv/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BR//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPwGtf//EABkQAAIDAQAAAAAAAAAAAAAAAAEQAAIRYf/aAAgBAQAGPwKoRe8n/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARITFBYf/aAAgBAQABPyG+CUcQrh2HT72Zjp8JVQ//2gAMAwEAAgADAAAAEAgf/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQBB/9oACAEDAQE/ECA7f//EABYRAQEBAAAAAAAAAAAAAAAAAAEAQf/aAAgBAgEBPxASjL//xAAbEAEBAQACAwAAAAAAAAAAAAABEQAxkUFRof/aAAgBAQABPxD10CPORreUSaZoP71ADjjIAUS9Z5hUD27/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/5c651022e88cb8deeabde4c2c3bf293a/72e01/04.jpg\"\n        srcset=\"/static/5c651022e88cb8deeabde4c2c3bf293a/e4a55/04.jpg 256w,\n/static/5c651022e88cb8deeabde4c2c3bf293a/36dd4/04.jpg 512w,\n/static/5c651022e88cb8deeabde4c2c3bf293a/72e01/04.jpg 1024w,\n/static/5c651022e88cb8deeabde4c2c3bf293a/ac99c/04.jpg 1536w,\n/static/5c651022e88cb8deeabde4c2c3bf293a/e1596/04.jpg 2048w,\n/static/5c651022e88cb8deeabde4c2c3bf293a/d2602/04.jpg 4032w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>패킷을 택배라고 생각해보자. 철수가 영희한테 책을 보내려고 한다 해보자. 책을 영희한테 보내는게 목표인데 이걸 달성하기 위해서 수단을 정해야한다. 이 수단을 택배로 가정해보자. 제일 먼저 하는게 철수가 책을 준비해야 할 것이다. 그 다음에 박스를 구해서 책을 박스에 집어넣고 테이핑 후 송장을 붙여서 택배 기사 아저씨한테 전달드려야 할 것이다. 그러면 택배기사님은 그 택배를 트럭에 싣고 물류센터에 가서 송장에 적힌 영희네 목적지 주소로 가는 택배트럭에 싣고 영희네 집으로 갈 것이다. 여기서 중요한것은 철수가 택배기사님한테 택배를 전달하는 그 순간 철수 손에 떠나는거고 철수의 개입없이 기사님은 영희네 집에 가서 전달을 한다. 그럼 여기서 궁금한게 목적지 주소는 영희네 집으로 가기위해 필요하지만 출발지 주소와 보내는 사람은 왜 필요할까? 만약 택배기사님이 영희네에 갔는데 아무도 없어서 문 앞에 두실수 있고 아니면 영희네 어머니가 받아서 영희한테 전달을 할 수 있을 것이다. 이때 영희는 누가 보냈는지 출발지 주소와 보내는이를 보고 누가 보냈는지 알 수 있을 것이다.</p>\n<p>그럼 이제 네트워크로 보자. 철수 영희를 프로세스로 보자. 그럼 철수라는 프로세스가 책이라는 데이터를 보내기 위해 TCP/IP를 추상화한 파일형태의 인터페이스 즉, 소켓에 write를 할 것이다. 이때 socket에 write라 하지 않고 송신한다고 한다. 그럼 그 data가 TCP를 만다 그 데이터를 payload에 넣고 앞에 TCP header를 붙여서 Segmant화한다. 그리고 그 Segmant를 IP를 만나 IP header를 붙여서 Packet으로 구성하고 Driver로 내려가면 Frame header를 붙여서 NIC(랜카드)에 전달한다. 그럼 그 Frame을 L2 Access Switch, Router를 거쳐서 영희 프로세스한테 가게 된다. 이때 이 과정을 앞서 살펴본 Encapsulation이라고 한다.</p>\n<h3>TCP 특징</h3>\n<ul>\n<li>연결지향 - 3 way Handshaking</li>\n<li>데이터 전달 보증</li>\n<li>순서 보장</li>\n<li>신뢰할 수 있는 프로토콜</li>\n<li>현재는 대부분 TCP 사용</li>\n</ul>\n<p>그러면 한번 전송과정을 상세히 풀어보겠다. 파리에서 에펠탑을 택배로 보내려면 어떻게 해야할까? 일단 가능은 할까? 가능은 하다. 일단 첫째로 에펠탑을 분해해가지고 크기를 줄여야하는데 택배박스 크기로 줄여야 한다. 즉, MTU이하로 줄여야 할 것이다. 그렇게 해서 다 분해를 한 다음에 둘째로 운송을 하면 된다. 그 다음 셋째로 조립해야 한다. 과정이 상당히 심플하다. 그런데 여기서 분해라고 하는것은 송신측에서 할 것이다. 조립은 수신측에서 할 것이다. 여기서 택배박스는 패킷일것이다. 인터넷이라는 정보의 물류체계에서 패킷이라는 단위로 정보가 유통된다. 여기서 전체적인 프름이 중요한데 이 흐름이 나왔다는 것은 TCP/IP를 묶어서 설명하겠다는 것이다. PC가 1대가 있는데 이 PC가 L2 Access Switch, L2 distribution Switch, Router를 거쳐서 Internet에 도달할 것이다. 그럼 수신측에서 Router를 거쳐서 L2 distribution Switch, L2 Access Switch를 거쳐서 서버가 있다고 가정해보자. 예를 들어서 위의 그림의 서버가 네이버라고 했을 때 네이버의 파일 하나를 다운로드 한다고 해보자. 이 파일 다운로드라는 것은 사실 네이버 입장에서는 파일이라는 정보를 송신한다는 것이고 PC쪽에서는 수신하는것이다. 근데 중요한것은 인터넷이라는 구간안에서 정보가 유통될때 패킷형태로 전달된다. 그런데 만약에 파일이 1.4MB라고 가정하면 패킷 MTU가 1.4KB이고 차이가 1024배 이상 차이가 나는데 즉, 1000개 이상 패킷으로 바꿔서 날라간다. 그리고 결국 파일을 송신하거나 수신하는것은 PC 혹은 서버라고 애기했지만 정확히 말하면 프로세스가 송수신을 한다. 그래서 이런걸 기반으로 깊이 애기해보자.</p>\n<p>파일을 TCP/IP로 보낸다고 가정을 하면 TCP라는 것은 연결지향형 프로토콜임으로 연결이라는 것을 한다는 것은 일종의 전화 통화 연결과 유사하고 이것을 한 다음에 송수신이 이루어진다. 그럼 그렇게 송수신이 잘 되었다고 가정하고 위 그림에 오른쪽의 프로세스를 서버라고 가정하자. 그리고 내려가면 TCP 프로그램을 추상화한 파일형태의 인터페이스인 소켓이 있다. 서버쪽의 HDD 혹은 SSD라는 보조기억장치라는 것이 어딘가 있을 것이고 파일이라고 말하는 것은 이 안에 저장되어 있을 것이다. 이 파일이 1.4MB라고 가정한다 했을 때 여기서 중요한것은 소켓의 본질이 파일이라고 했는데 이 소켓에 대고 I/O가 일어날 것이다. 이런 I/O가 일어날때는 소켓에 attach된 메모리 공간 즉, 버퍼가 있기 마련이다. 이런 버퍼가 있으면 buffered I/O가 일어나는 것이고 이거 없이 I/O를 직접하면 non-buffered I/O를 하게 된다. 근데 문제가 뭐냐면 소켓에도 버퍼가 있지만 이 서버 프로그램 안에도 개발자가 분명히 파일 같은걸 읽는것 때문에 버퍼가 있을 것이다. 이 버퍼의 크기는 개발자가 지정하기 나름인데 암튼 이 버퍼는 프로세스가 관리하는 버퍼이고 그 밑의 버퍼는 소켓 I/O 버퍼이다. 그러면 어떤 일이 일어나냐면 1.4MB정도 파일을 보내야 한다면 프로세스가 관리하는 버퍼의 크기는 1.4MB가 될 수 있지만 이 크기는 개발자가 직접 정한다. 몽땅 메모리에 올릴 수 있고 그 일부를 메모리에 올릴 수도 있다. 그런데 예를 들어 직소퍼즐이 있다고 해보자. 이 직소퍼즐중에 5개의 퍼즐을 블록형태로 짤라온다고 해보자. 이 잘라온 직소퍼즐조각을 프로세스가 관리하는 버퍼에 넣는다. 그러면 직소퍼즐 5개가 버퍼에 넘어올 것이다. 즉, 이 직소퍼즐이 copy가 되는 것이다. 이 읽어온 직소퍼즐을 프로세스가 메모리에 담는다. 그러면 이 버퍼에 있는 데이터를 소켓 I/O가 관리하는 버퍼쪽으로 copy가 일어난다. 이때부터 전송이 일어나는데 user-mode에서 커널 모드로 넘오올때 TCP 스택을 만날때 분해가 일어난다. 즉 전송한 직소퍼즐을 분해해서 짜른다. 이때 user-mode에 버퍼안에 데이터 단위를 스트림이라고 한다. 이 스트림은 파일 전체를 읽어서 보내야 끝이 난다. 문제는 TCP 스택을 만나 Segmentation이 일어나는데 이 중 하나의 조각을 넘버링을 1번붙어 붙여서 세그먼트화 시킨다. 그 다음에 IP쪽으로 내려와 택배상자에 세그먼트를 넣어서 테이핑하여 패킷을 만든다. 이 패킷 헤더에는 송장과 같이 출발지, 목적지 주소가 있다. 그리고 이 택배상자를 택배기사 아저씨한테 전달하여 이 기사 아저씨는 택배 트럭에 상자를 넣는다. 이때 택배 트럭을 프레임이라고 한다. 여기서 중요한것은 이 트럭이 나한테 택배를 전달받자마자 바로 목적지로 갈까? 그렇지 않고 물류센터에 가서 분류하고 다른 택배트럭에 싣고 목적지로 갈 것이다. 즉, 유통과정에서 프레임은 수시로 바뀐다. 이렇게 해서 데이터가 송신된다. 즉, 송신측에 Encapsulation이 일어난다. 그러면 수신쪽에는 어떤 일이 일어날까? 트럭이 목적지 주소까지 가고나면 송신쪽의 정반대 일이 일어난다. 송신쪽 프레임과 다른 프레임이 수신지에 오면 택배박스라는 패킷이 나와 타고 올라갈 것이다. 그리고 IP까지 타고 올라가서 택배상자를 꺼내 내용물을 확인하듯이 패킷에 세그먼트를 꺼내 패킷을 버리고 세그먼트를 TCP 계층까지 올라간다. 이렇게 Decapsulation이 일어나고 이 세그먼트 한 조각을 소켓 I/O 버퍼에 올라간다. 그리고 이 세그먼트 조각을 다시 프로세스 버퍼에 올린다. 이렇게 나머지 세그먼트도 송수신을 하면서 수신쪽 소켓 I/O는 여유공간이라것이 줄어들고 프로세스 버퍼에 올리면 여유공간이 확대된다. 그러면 여기서 문제가 발생할 수 있다.</p>\n<p>만약 송수신과정에 세그먼트가 없을 경우가 있다. 이것을 Loss라고 하는데 이것은 네트워크 자체 문제일 경우가 크다. 둘째로 송신측에서 세그먼트를 일정수준 보내면 수신측에서는 잘 받았다고 ASK라고 피드백을 여유공간이 얼마나 남았는지 보내줘야 하는데 응답이 없다면 송신측은 보낸 세그먼트를 재전송(Re-Transmission)을 한다. 그런데 간발의 차로 바로 ASK가 오는 경우가 있는데 이것을 ASK-Duplicated라고 한다. 이것은 네트워크상 문제일수도 있고 end-point간 합이 안 맞아서 일어날 수 있다. 그 다음으로 Out of Order가 있는데 이게 뭐냐면 1,2번 세그먼트가 오고 3번 세그먼트가 와야하는데 3번이 안 오고 4번이 오는 경우라던가 혹은 4번이 오고 3번이 나중에 오는 경우가 있다. 이런것은 거의 네트워크상 이슈다. 마지막으로 Zero Window가 있는데 수신측 여유공간 메모리 크기를 window size라고 하는데 zero라는 것은 process buffer가 빨리 비워줘야 하는데 안 비워준 경우 즉, 네트워크 송수신 속도가 프로세스가 비워내는 처리속도보다 빠른 경우에 발생한다. 이러면 송신은 되도 수신이 안되는 상태가 발생하는데 이런경우 end-point간 application이 문제임으로 이 부분을 확인해봐야 한다.</p>\n<h3>3 way handshaking</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 919px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.1875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACjklEQVQ4y3WTy24cRRSG+yGQiJLpru6ue/VtZtpqzyVzky3iYBsSBUciC1AgO0CIPWLDDolV3gMeigf5UJXlhA2LX1WLqq/OOf9fWQiBZ5dHtutzZrM8SZY5ThaoWmBqga4FTgkOQ85+yNkNBbtBMHiJliW7zcSXN1c8uzyQWRe4unvH8eols9kT8qKgKgVeFbikuBcEXTIGwdQIzpqSqa2YB0nQFdtpwZvXL3n1xXOyXHec/vyHxTfvefLoE0RZIURJWX5UVVXUdU1VS8pKUktFLTVKaYzWqYCv3/7A5ecvyHzT8ebtL3x2/VWCxQulEBRFgRAiwaLyPE9wpVSS1vp+tZ7Y5fXtDbv9nqwQgpMUjFVBITW1sgnUti3GmASz1nI4HJimCa0V1his0UneB5p+4HYcOfQ9WbrQdvRtg7MNlWmppGa+WKbDsdUIGYaBvu/wVuGNpPOazksWnWe5XLJZjvTOkWljeH55ZL/d0LWeYGUywkhBcJrT6cTFxQX7/Z75fE7X95yv1hgXcKHDtgvW2x2bp0+x3pPlhWBuHqNFngYdZyPrEiVrtJLEWHVdxziOaXXeJ6gxFmsdrhkYpxXb7ZZ+mJPF4Z/ZRzjxGBWd8wO1MqzWG/p+SA+E4FOl6/WKxmlabxgay9AYzobAauzZTAuCKckqHdhv1zTLLaY9Q2qLlDJVEE2JwA+Oao2zFucs3juCt7T9gsO3v3P943uO3/1B1h/vePXrX9z99jfTi5+pqo/ReIBERXh0+14O7/09tFuwvn3HxeufOL/5nqyKwS3j78iRyqRcKSU/gB5gD0Dn7mFxthHYtAPOSEw9o5x9SlbVdYpGbDMm/7/t/R/sAZjUNDRtR9f1aGP5FwYpi4VYHtKcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/e415294534fe86591777a769e5e19e6a/6295b/05.png\"\n        srcset=\"/static/e415294534fe86591777a769e5e19e6a/6f3f2/05.png 256w,\n/static/e415294534fe86591777a769e5e19e6a/01e7c/05.png 512w,\n/static/e415294534fe86591777a769e5e19e6a/6295b/05.png 919w\"\n        sizes=\"(max-width: 919px) 100vw, 919px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>TCP 연결 절차에 대해 이야기할 때 3-way-handshaking이 늘 등장한다. 연결이라는 것이 결론이라면 그 연결의 과정으로 등장하는 것이 3-way-handshaking이다. 위 그림처럼 어떤 client가 있다면 접속 대기중인 서버에 접속을 할 것이다. 위 그림의 세로 선을 timeline이라고 하고 어느 시점에 클라이언트가 192.168.0.20:80번의 서버와 연결을 하고자 한다. 여기서 클라이언트가 서버에 갔다가 돌아오는 시간을 RTT라고 하는데 50ms정도 걸린다고 하면 서버까지 가는 시간을 25ms, 돌아오는 시간을 25ms라고 가정하자. 이때 통신되는 단위가 Segment인데 일반적으로 Segment는 payload와 TCP-header로 구성되어 있지만 3-way-handshaking은 TCP-header만 존재한다. 즉, 이런 형태의 관리목적 Segment가 왔다갔다 한다.</p>\n<p>연결을 하려는 클라이언트 측에서 서버와 연결을 하고자 먼저 Sequence Number를 생성한다. 이 번호는 랜덤으로 생성이 되는데 예를들어 1000번이 생성이 되었다면 연결하는 서버한데 SYN(1000)을 보낸다. 즉, 클라이언트는 SYN_SENT를 한다. 그러면 서버는 연결가능 상태이면 Sequence Number를 랜덤생성하고 그게 4000이라고 하면 SYN(4000) + ACK(1001)을 클라이언트에 보낸다. 이걸 보내기 전에 소켓으 listening 상태로 변해야 한다. 그러면 클라이언트가 잘 받았다고 서버한테 ACK(4001)을 보낸다. 중요한것은 여기서 시간차가 존재하는데 이 시간차가 무엇이냐면 클라이언트가 연결을 시도해서 ACK를 받는 순간 클라이언트는 서버와 연결되었다고 판단한다. 하지만 이 시점 서버는 클라이언트와 연결이 안되었다고 생각한다. 단방향 RTT에 25ms가 지나면 ACK(4001)을 클라이언트가 보낸다. 이 ACK를 서버가 받은 시점에 서버는 드디어 클라이언트와 연결되었다고 생각한다.</p>\n<p>여기서 연결과정에 중요한것은 정책을 교환한다는것인데 정책중에는 위에서 언급한 Sequence Number가 존재하고 더 중요한 것은 MSS가 어느정도인지를 알려준다. 여기서 클라이언트와 서버의 MSS가 같으면 문제 없지만 클라이언트 MSS보다 서버 MSS가 작을때는 클라이언트의 MSS를 서버의 MSS의 맞춘다. 결론으로 연결이라는 것은 이런 관리적 정보, 프로토콜이 규정하는 정보를 교환하는 것이다.</p>\n<p>중요한 것은 여기서 연결이라는 것은 가짜다. 가짜로 연결한거지 실제로 연결한 것은 아니다. 그러면 한번 실제로 왜 착각인지 자세히 이야기 해보자. TCP연결이 착각이라고 말했는데 이것과 관련해서 악용한 해킹사례가 있었다.</p>\n<p>연결은 사실 End-point의 주관적인 판단에 불과하다. 즉 보안성이 전혀없는 판단이라는 것이다. 그래서 연결이 그 자체만으로 취약하다. 어떤 게임에서 이것과 관련한 버그가 있었다. 어떤 게임이 있으면 서버가 있을 것이고 서버에 사용자들이 접속해 있을 것이다. 예를들면 철수,영희,길동이가 접속해 있다 하자. 여기서 철수는 고렙이고 영희는 저렙이고 길동이라는 적군을 물리쳐야 한다고 하자. 그래서 고렙인 철수는 영희와 연합을 해서 길동이를 물리치고 싶은데 영희는 아이템도 없고 저렙이다 보니 어떻게 할까 생각을하다 이상한 생각을 하게된다.</p>\n<p>철수 영희만 볼 수 있는 한적한 공간으로 이동을 한다. 그리고 철수는 아주 좋은 아이템을 길에 버린다. 그러면 철수, 영희 모니터 화면에는 좋은 아이템이 바닥에 버려진 화면을 공유할 것이다. 그리고 철수는 이 아이템을 다시 줍는과 동시에 LAN선을 뽑아버린다. 그러면 어떤 일이 일어나냐면 영희 화면에는 아이템이 바닥에 여전히 버려졌지만 철수는 아이템이 습득되어 있다. 이것을 확인하고 철수는 다시 LAN선을 연결한다. 그럼 TCP연결은 유지됨으로 영희는 이 아이템이 획득이 가능해지고 아이템 복제 버그가 일어난 것이다.</p>\n<p>이 이야기를 한 이유가 바로 TCP연결은 주관적인 판단이고 착각이라고 말하고 싶었다. 즉 클라이언트가 SYN을 날려 연결요청을 하고 서버가 SYN+ACK를 날리면 클라이언트는 서버와 연결이 되었다 착각을 한다. 서버는 클라이언트에 ACK가 날라오기 전까지 연결이 안된것임에도 불구하고 말이다. 그래서 TCP연결에 딸려오는 말이 보안성이 없다는 것이다.</p>\n<h3>UDP 특징</h3>\n<p>UDP 헤더를 보면 TCP에 비해 매우 간단하다. Source Port, Destination Port, Length, Checksum밖에 없다. 그래서 UDP는 혼잡제어를 하지 않고 수신측에 대한 고민을 전혀 하지 않는다. 즉, UDP는 클라이언트를 배려하지 않는 프로토콜이다. 그런데 이런 UDP를 언제 사용할까? 예를 들면 IPTV를 생각해보자. IPTV의 영상을 송출해주는 서버가 있고 이 서버와 연결된 많은 클라이언트들이 잇는데 누구는 N/W가 빠르고 누구는 느리는 경우가 있을 것이다. 그러면 이 중에 느린 N/W를 기준으로 맞추면 빠른 N/W 사용자는 손해를 볼 것이다. 그래서 이런것을 송출할 때는 모두를 고려하는게 아닌 일단 빨리 보낼때 이것을 사용한다.</p>\n<p>또한 게임서버를 생각해보자. 내가 LOL과 같은 게임을 만들고 싶으면 동기화가 중요하다. 문제는 TCP를 이용해 게임서버를 동기화하면 하향평준화가 되어 문제가 생길 것이다. 즉, 한놈이 느려지면 전체적으로 서버가 느려진다. 그래서 동기화를 위해 UDP를 사용한다. UDP를 이용하고 혼잡제어부분은 서버자체에서 구현을 하면 된다.</p>\n<p>또한 HTTP3에서도 UDP방식으로 사용된다.</p>\n<h2>PORT</h2>\n<p>어째저째 미국의 친구와 IP 연결이 완료되었다. 그런데 미국의 친구에 채팅 프로그램에 데이터를 전송해야 하는데 어떻게 채팅 프로그램한테 전달할까? 바로 TCP의 세그먼트에 출발지 PORT와 목적지 PORT가 존재하고 전송할 때 해당 포트로 전송을 하는 것이다. 그래서 미국의 친구에 메신저 앱에 무사히 도착해서 전달하는 것이다.</p>\n<ul>\n<li>0 ~ 65535: 할당 가능</li>\n<li>0 ~ 1023: 잘 알려진 포트, 사용권장X\n<ul>\n<li>FTP: 21, 22</li>\n<li>TELNET: 23</li>\n<li>HTTP: 80</li>\n<li>HTTPS: 443</li>\n</ul>\n</li>\n</ul>\n<h2>DNS</h2>\n<ul>\n<li>분산 구조형 데이터베이스\n<ul>\n<li>데이터베이스 시스템(DNS 네임서버)의 분산구성</li>\n<li>데이터 영역별 구분(Domain Zone) 및 분산관리</li>\n<li>도메인의 네임서버 및 도메인 데이터는 해당 관리주체에 의해 독립적으로 관리됨</li>\n</ul>\n</li>\n<li>트리구조의 도메인 네임(Domain Name) 체계\n<ul>\n<li>Domain: 영역, 영토를 의미</li>\n<li>도메인 네임의 자율적 생성</li>\n<li>생성된 도메인 네임은 언제나 유일하도록 네임체계 구성</li>\n</ul>\n</li>\n</ul>\n<p>OSI 7 Layer의 L1<del>L4는 Infra Structure로 볼 수 있다. L5</del>L7의 Application이 뭔가 목적화 되는 것이고 이 Application들을 위해서 Infra가 존재하는 것이다. 그래서 우리가 인터넷을 이루고 있는 각 종 서비스라는 것이 Application 계층에 존재한다. 근데 Application 계층에 존재하는 서비스중에 infra에 해당되는 것들이 있는데 그 중에 가장 대표적인게 DNS이다.</p>\n<p>여기서 DNS는 Domain Name Service이다. 뭐 별거 없고 네이버 같은데 접속할 때 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 주소창에 치고 엔터키를 누른다. 그러면 네이버 웹서버까지 TCP/IP 연결을 해야한다. 그러면 네이버 IP주소를 알아야 하는데 사용자 대부분 네이버 IP주소를 모를 것이다. 그런데 어떻게 네이버 IP주소를 알 수 있을까? 누가 이 IP주소를 알려줄까? 이걸 알고있는 DB가 있다. 예를들어 번호를 궁금할때 114에 전화를 걸면 알려주는것과 유사하다. 또한 우리가 친구한테 연락을 할 때 친구 전화번호를 직접 누르지 않고 주소록을 통하여 친구 이름을 검색하여 전화를 거는 상황과 유사하다. 즉 이름으로 검색을 한다. Domain Name도 결국 이름이고 이 이름으로 IPv4 주소를 검색하여 그 결과를 알려주는 서비스를 제공해주는 것이 DNS이다. 요즘 대부분이 웹기반으로 구현되기 때문에 DNS가 잘못되면 인터넷이 모조리 스탑된다. 그래서 DNS는 매우 중요한 인터넷 자원이다.</p>\n<p>DNS기능은 매우 간단하다. Domain Name으로 IP주소를 알려주는 기능을 한다. 그런데 DB를 자세히 들어가보면 분산구조형으로 되어 있다. 대부분의 경우 트리 구조로 되어 있는데 이런게 어떻게 되어지는지 생각해보자. 우선 Domain Name부터 생각해보자. <a href=\"http://www.naver.com%EC%9D%B4%EB%9D%BC%EB%8A%94\">www.naver.com이라는</a> 주소가 있는데 분류가 어떻게 되냐면 www는 작은 개념으로 naver라는것에 속하는 녀석이다. 근데 <a href=\"http://www.naver%EB%9D%BC%EB%8A%94\">www.naver라는</a> 것은 com이라는 녀석에 속하는 녀석이다. 즉, com이라는 것이 더 큰 개념이다. 서양주소체계가 우리나라 주소체계랑 다른것과 유사한개념으로 이해하면 쉬울 것이다. 그래서 Domain Name이라는 것은 naver.com이다. 그리고 이 도메인에 속한 www는 host name이다. 예를들어 <a href=\"http://www.naver.com%EC%9D%B4\">www.naver.com이</a> 뭐냐면 naver.com이라는 도메인에 속한 이름이 www인 host를 찾는 것이다.</p>\n<blockquote>\n<p>✅ 참고</p>\n<p><a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> URL 혹은 URI라고 불러야 하는데 통상적으로 URL이라는 표현을 많이 쓸 것이고 URL 주소라고 많이들 부른다.</p>\n</blockquote>\n<p>그래서 이 주소라는 것이 Domain Name과 Host Name으로 나눠져 있다. 보통 질의를 할때 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 통으로 질의를 하고 DNS가 그것을 보고 IP주소를 알려준다. 그러면 왜 이런 것들이 분산구조형이라고 하는지 이야기해보자.</p>\n<p>우리가 인터넷을 쓰는데 KT,SKT,LGU+등 여러 ISP를 통해 인터넷을 이용할 것이다. 예를 들어 철수가 KT같은데서 인터넷 회선을 끌어다가 사용한다고 해보자. 그러면 일정 금액을 지불하고 인터넷을 사용할 것이다. 그런데 공유기를 활용해 PC, Mobile등 여러 디바이스가 인터넷을 사용할 수 있을 것이다. 근데 중요한 것은 철수가 크롬 주소창에 <a href=\"https://www.naver.com\">https://www.naver.com</a> 이라 치고 엔터키를 누르면 어떻게 될까? 이 PC의 IP설정(DNS 주소)을 기반으로 작동이 될 것이다. OS가 윈도우라고 가정하면 윈도우 OS내부에서 KT DNS서버한테 질의를 할 것이다. '네이버에 접속하려는데 <a href=\"http://www.naver.com\">www.naver.com</a> IP주소좀 알려줘'라고 보낼 것이다. 그럼 DNS서버가 응답으로 IP주소를 줄 것이다. 그럼 그 IP주소를 보고 접속을 하게 될 것이다. 그래서 중요한 것은 DNS주소는 보통 ISP에서 정해주는 것을 사용한다. DNS 응답이 느려지면 인터넷 전체가 느려질 수 있고 사용자 입장에서는 네이버 너무 느리다라고 판단하는 착오가 있을 것이다.</p>\n<p>만약에 철수가 ISP 어딘가를 빼서 Google DNS(8.8.8.8)로 세팅을 했다면 네이버 접속할 때마다 Google DNS한테 물어봐야 하는데 응답시간이 매우 길어질 것이다. 왜냐하면 ISP DNS 서버보다 Google DNS 서버가 너 멀리 있기 때문이다. 그래서 보통은 ISP DNS서버를 사용한다.</p>\n<p>이렇게 IP주소를 알아내면 알아냄과 동시에 네이버 서버에 접속할 것이다. 이때부터 HTTP 통신을 하게 되고 이런 통신을 하면서 브라우저로 네이버 화면을 볼 수 있을 것이다. 여기서 추가적으로 알아야할께 PC가 한번이라도 DNS한테 질의를 하면 예를들어 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 질의하면 DNS는 네이버 IP를 반환하고 이 IP를 PC의 RAM에 저장해두고 있는데 이것을 DNS 캐시라고 한다. 그래서 PC마다 이 DNS 캐시를 가지고 있다. 윈도우에서 명령프롬프트에 다음과 같은 명령어를 치면 DNS 캐시내용이 출력될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">displaydns</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그런데 중요한 것은 응답이라는 것이 오면 IP주소와 같이 오는것이 있는데 바로 유효기간이다. 이 유효기간까지만 캐시가 되고 그 이후에는 다시 DNS에 물어야하고 그 유효기간 내에서는 DNS한테 질의하지 않고 바로 캐시를 보고 접속을 한다 그러면 왜 캐시를 하는 것일까? 쉽게 생각해서 DNS한테 계속 질의를 하면 DNS서버에 부하가 심하게 생길것이기 때문이다. 그래서 한번 질의를 하면 그 이후 캐시를 통하여 접속을 한다. 여기서 중요한게 보안이다. 만약 DNS서버가 거짓말을 하면 어떨까? 내가 DNS한테 네이버 주소를 알려달라고 했는데 다음주소를 알려주면 어떻게 될까? 주소창에 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 입력했는데 다음 홈페이지가 나올것이다. 그래서 DNS가 해킹같은것을 당하면 매우 큰일이 남으로 DNS는 보안이 생명이다.</p>\n<p>PC입장에서 DNS캐시가 존재한다. 또한 이것뿐만 아니라 윈도우의 hosts파일이 존재한다. 우리가 인터넷뱅킹을 할때 보안프로그램이 활성화되면서 이 프로그램의 약관을 살펴보면 hosts파일을 보호한다고 되어있다. 이 hosts가 무엇이냐면 IP주소와 url이 기입된 파일이다. 만약에 hosts가 있다면 PC는 DNS한테 질의하지 않고 이 파일에 써져있는데로 움직인다. 그래서 옛날 악성 바이러스가 이 파일을 많이 조작하고 감염시켰다.</p>\n<blockquote>\n<p>✅ 참고</p>\n<p>공유기 IP와 DNS주소가 같을 수 있는데 공유기 자체는 DNS가 아님으로 공유기에서 DNS 포워딩 기능을 이용해서 공유기가 DNS를 대행해주는 기능이 있다.</p>\n</blockquote>\n<p>브라우저에 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 치면 ISP에 DNS에 어느 누구도 <a href=\"http://www.naver.com%EC%9D%84\">www.naver.com을</a> 요청한적이 없다면 어떻게 될까? 일단 PC가 DNS에게 네이버 IP주소를 요청할 것이다. 여기서 DNS도 일반 DNS가 아니라 Cache DNS인데 이 DNS는 캐싱을 어떻게 하는것일까? 지구상의 DNS는 계층적 구조를 지니는데 그 정점에 있는 DNS가 Root DNS이다. 이 DNS는 한국은행처럼 DNS를 위한 DNS이다. 그럼 본론으로 Cache DNS가 Root DNS한테 누군가 <a href=\"http://www.naver.com%EC%9D%B4%EB%9D%BC%EB%8A%94\">www.naver.com이라는</a> IP주소를 묻는데 com에 관련된 애들을 알려달라고 요청을 하고 Root DNS는 도메인 이름중에 com으로 끝나는 Domain 관리 DNS 몇대를 소개해주고 이 DNS의 IP주소들을 목록화하여 보여준다. 그럼 이중 1대를 지정해서 네이버를 아냐고 물어보고 안다고 하면 Naver name Server를 알려준다. 그럼 그 서버에 host name이 www인 PC를 알려달라고 요청을 하게 되고 그때 드디어 IP주소를 반환하게 된다. 그리고 Cache DNS는 이 IP와 url을 쌍으로 저장하게 되는 구조로 작동한다.</p>\n<blockquote>\n<p>잘못된 지식이 있을 경우 댓글로 남겨주시면 빠르게 반영하겠습니다!</p>\n</blockquote>","fields":{"slug":"/네트워크-기본-이론/"},"timeToRead":14,"frontmatter":{"title":"[자바 고급2] 네트워크 - 기본 이론","tags":["자바"],"date":"2025-05-23T22:44:27.000Z","image":{"publicURL":"/static/3189e9c0404650ccc6c5ffc998bc8717/banner.png"},"series":"자바 고급2"}}},"pageContext":{"id":"aee9a7ea-9149-5a7c-a8fd-99559d04a418"}},
    "staticQueryHashes": ["2580406332","3810308631"]}