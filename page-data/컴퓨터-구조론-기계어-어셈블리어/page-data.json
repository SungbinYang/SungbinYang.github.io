{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/컴퓨터-구조론-기계어-어셈블리어/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":1},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":3},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":2},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"e2337289-9824-55bb-8758-e34fd7c9b3b4","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVQoz51Sy3LCMAz0/38WkBexE549lQCNEydhptBAz9uRPAYnHdpODxprpUjaVSR0FMBZGc7g47/YuEaME2Uw/dHeZpMHdjVeUzGYFkxhcoVus0Yt5zCZZGxUyj7Fus3KxjOJah4/Z2gbTnB62eJ994pel/g8dbg1xr5di2tdMabc1dRoVwsm4bMU5DhAcuitZcrT2ZIIzSJjdmSEbS7hurF04ctt10uWQpikNnnGzVheEkEnEUymUKcJdBxyUxoyYHgHcWiltQ3O+wKXfcE+SSR5faXxcTzgXOwYU/xyPKDXerDLQUOjJDNwP+FhyuaU5HUQ62aZs0/fftuhC/x2MgPzzude73b4n4N+duBfEs24R4/6hrYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png\"\n        srcset=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/6f3f2/banner.png 256w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/01e7c/banner.png 512w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png 700w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>본 포스팅은 인프런의 <a href=\"https://inf.run/PnrRu\">만들면서 쉽게 배우는 컴퓨터 구조</a>를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>기게어 프로그래밍</h2>\n<p>이번에는 완성된 컴퓨터를 이용해 프로그램을 실행해보도록 하겠다. 우리가 만들 프로그램은 1+2의 결과를 출력하는 간단한 프로그램이다. 메모리에 1과 2를 미리 저장해두고 이를 레지스터로 불러와 계산하는 방식으로 프로그래밍을 진행하도록 하겠다. 우리의 RAM은 총 16바이트 크기로 0번부터 15번까지 총 16개의 메모리 공간을 제공한다. 이때 15번 주소에는 1이 14번 주소에는 2가 저장되어 있다고 가정하자.</p>\n<p>먼저 15번지에 있는 데이터 1을 레지스터 A로 가져오자. 레지스터 A로 데이터를 가져오는 명령어는 LOADA 명령어이다. 명령어표에서 LOADA의 OP코드를 확인해보면 0001이다. 그러면 명령어의 상위 4비트는 0001로 넣어준다. 우리는 15번 주소에 있는 1을 가져오고 싶기 때문에 명령어의 하위 4비트, 즉 operand를 15로 입력해야 한다. 15는 2진수로 1111이기 때문에 operand를 1111로 적어준다. 이렇게 2진수로 된 명령어를 16진수로 변환하면 1F가 된다. 이 1F를 0번 주소에 저장할 것이다.</p>\n<p>다음으로 어떤 명령어를 사용해야 할까? 현재 레지스터A에 1이 저장되어 있으므로 ADD 명령어를 이용하여 RAM의 14번 주소에 있는 값, 즉 2와 덧셈을 진행해야 한다. ADD 명령어의 OP코드는 0010이고 14번지는 2진수로 1110이다. 해당 2진수를 16진수로 변환하면 2E가 된다. 그럼 2E를 1번 주소에 저장할 것이다. 이 명령어가 실행되면 레지스터 A에는 1+2의 결과인 3이 저장될 것이다.</p>\n<p>이제 이 레지스터에 저장된 결과를 출력 레지스터로 전송하는 OUT 명령어를 사용하겠다. OUT 명령어의 OP코드는 1110이며 operand는 필요 없으므로 0000으로 해준다. 이는 16진수로 E0가 된다. 그리고 해당 값을 2번주소에 저장할 것이다.</p>\n<p>출력이 완료되었으니 이제 컴퓨터의 동작을 중지시켜야 할 것이다. 이를 위해 HLT 명령어를 사용할 것이다. HLT 명령어의 OP코드는 1111이고 operand는 필요 없으므로 0000이다. 이것을 16진수로 표현하면 F0가 된다. 그리고 해당 결과를 3번 주소에 저장할 예정이다.</p>\n<p>이제 이 프로그램을 로지심에서 직접 실행시켜보겠다. 일단 메모리를 우 클릭하여 Edit Content를 통해 아래와 같이 작성해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.453125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACZElEQVQ4y22Sa08TQRSG+/dNTIwXFPESv/jFxMRIDJIKihRDoJQCLaV0a5del3bbzk53u/d9zAyUAHKSN3PZOc++c87knn8rsvy9xMpGlbebVV7nj3i2usfSepnna2Uef9nlyeo+L9YO9d7yjwov8xU+/Drl3WaFlQ2lE97/rPIqf0KuUT/FHQ+BBLIIkhDigCRwSQMPyCBVez6+O0VOh0S+ZO5OIYuvvpNen4vIHZRKCEeiIkkzLbUuHpTY3ilgmE3Miy6tiw6l40O2Czs0zRaV5ilBEBLFCWEUEycJ3twnVywWMQyDJEk0NI5jpJTEUcyRccxRt8LfVotz4xzLsiiXy/q87/s6R51XY5qmBEFArl4/p91u64WKKIoQU8HIGVN+s0H/6S4zW2BPbNyZi+u6zGYzwjDUoIVugLVaiZvIMqIwRDqSyUxgfP1D5+MWZq9Jp98lSzOdqHTb3WJUrnMnlV0sa0iYpUSA8jn35oxGFp3WEtPwjHLtmHrDQLoenje/A/nPYbV6SrvfxyoUkPk8/t4enuchhE2n9fu6DCohI06uGpamyR3YAqgdNptNnSQtC38wACmZSUmWZUgZICZThvaI/sCiP7hEOI5Ovu9QSdU1Z5qmboTZ6WDZNmGaMBUOcZRSNRusFwvUjHMajQbD4aW+1kMOlRQn1+v1tMPxeMxoNNLzTrdPrVLnU3mLR4XPbO8f0Db7RFFGGEa6BA8BtUPV2asGZ1rqOqqGjuMwnk7oWQPssc3AsjirN7AGAiFUp2Pi+AHgcCz0QxZC6PelQEmcaPjiZyrSTNUt0pD7oNvAf3pV0ZWJmgY4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image01\"\n        title=\"image01\"\n        src=\"/static/28226baa3b464821773502f8486ca008/2bef9/01.png\"\n        srcset=\"/static/28226baa3b464821773502f8486ca008/6f3f2/01.png 256w,\n/static/28226baa3b464821773502f8486ca008/01e7c/01.png 512w,\n/static/28226baa3b464821773502f8486ca008/2bef9/01.png 1024w,\n/static/28226baa3b464821773502f8486ca008/71c1d/01.png 1536w,\n/static/28226baa3b464821773502f8486ca008/a878e/01.png 2048w,\n/static/28226baa3b464821773502f8486ca008/f7171/01.png 3456w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 프로그램이 RAM에 로드되었다면 클럭을 동작시켜 프로그램을 실행시켜주면 된다. 우리가 한 과정을 기계어 프로그래밍이라고 한다.</p>\n<h2>어셈블러와 어셈블리어</h2>\n<p>우리는 1+2를 계산하기 위해 명령어표를 참조하여 LOADA, ADD, OUT, HALT 명령어에 해당하는 2진수를 작성했습니다. 이처럼 우리가 원하는 동작을 수행하기 위해 명령어표를 참고해 명령을 2진수나 16진수로 변환하는 과정은 매우 번거롭다. 뿐만 아니라 오타가 발생하면 이를 찾아내기 어렵다.</p>\n<p>기계어의 이런 단점을 해결하기 위해 컴퓨터 과학자들은 명령어표의 명령어를 직접 사용할 수 있는 언어로 만들었다. 이것이 바로 <strong>어셈블리어</strong> 또는 <strong>어셈블리 언어</strong>라고 말한다. 어셈블리의 각 명령어는 기계어와 1:1 매칭을 한다. 예를 들어 레지스터A에 RAM의 10번 주소에 있는 데이터를 저장하기 위해 이전에는 0001 1010이라는 기계어를 사용했지만 어셈블리 언어에서는 LOADA 10이라고만 해주면 된다. 이러한 어셈블리 언어를 기계어로 변환해주는 프로그램을 어셈블러라고 한다.</p>\n<h2>어셈블리 언어 프로그래밍 - 곱하기</h2>\n<p>이번에는 어셈블리 언어를 통하여 곱셈을 수행하는 프로그램을 만들어보겠다. 예제로 5x4를 구현해보겠다. 5x4는 5를 네번 더하는 방식으로 구현할 수 있다. 이러한 반복 작업을 수행하기 위해서는 조건을 검사하고 조건이 만족되었을 때 특정 위치로 이동하는 명령어가 필요하다. JMP, JMPC, JPMZ같은 JMP 명령어가 필요한셈이다.</p>\n<p>그러면 지금부터 프로그래밍을 시작해보겠다. IDE는 vscode를 사용해보겠다. 일단 <code>5x4.asm</code>파일을 만들어준다. 확장자 asm은 어셈블리 언어로 작성된 파일임을 나타내지만 다른 확장자를 사용해도 무방하다. 우리는 5x4를 진행하기 때문에 숫자 5와 4를 RAM에 저장해주겠다.</p>\n<p>먼저 RAM의 크기인 16만큼 텍스트 라인수를 만들어준다. 그리고 16번 라인, 즉 RAM 15번 주소에 5를 입력해준다. 15번 라인, 즉 RAM 14번 주소에는 4를 입력해준다. 그리고 14번 라인, 즉 RAM 13번 주소에는 곱샘의 결과를 저장해주겠다. 초기 값은 0으로 설정해주겠다. 5x4는 5를 4번 더해줘야 하므로 덧셈을 4번 반복해야 한다. 4를 시작으로 한번 반복할 때마다 1을 빼주기 위해서 메모리에 1도 저장하겠다. 13번 라인 즉, RAM의 12번 주소에 1을 입력해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">\n\n\n\n\n\n\n\n\n\n\n\n1 // 반복할 때 빼주는 값\n0 // 곱셈 결괴\n4 // 승수\n5 // 피승수</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 계산에 필요한 데이터들 입력은 모두 끝이 났다. 이제 명령어 부분을 작성해주겠다. 가장 먼저 곱셈의 승수, 즉 현재 덧셈을 반복해야 하는 횟수를 레지스터A에 불러오겠다. LOADA 14명령어로 레지스터A에 4를 불러온다. 다음으로 반복 횟수에서 1을 빼서 한번 반복을 카운팅해준다. 이는 SUB 12 명령어로 수행하는데 RAM의 12번 주소에 저장된 1을 레지스터 A의 값 4에서 빼서 3이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">LOADA 14 // A = RAM[14]\nSUB 12 // A -= RAM[12]\n\n\n\n\n\n\n\n\n\n\n1 // 반복할 때 빼주는 값\n0 // 곱셈 결괴\n4 // 승수\n5 // 피승수</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 반복 회수를 파악하고 분기하는 명령어가 필요하다. 현재 레지스터A에 저장된 승수가 양수일때는 ALU의 CF가 비활성화되는데 이를 활용해 JUMPC 명령어를 사용한다. 점프할 주소는 나중에 결정하겠다. JMPC가 실행되지 않을 때, 즉 현재 레지스터A에 저장된 승수가 음수가 되어 계산이 완료되었을 때 명령어를 작성하겠다. RAM의 13번 주소에 있는 계산 결과를 LOADA 13으로 레지스터A에 불러오고 OUT 명령어로 출력 레지스터에 저장한 뒤 HLT 명령어로 프로그램을 종료하도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">LOADA 14 // A = RAM[14]\nSUB 12 // A -= RAM[12]\nJMPC ?? // CF 활성 시 ??주소로 점프\nLOADA 13 // 13번 주소에 있는 곱셈 결과를 레지스터A에 저장.\nOUT\nHLT\n\n\n\n\n\n\n1 // 반복할 때 빼주는 값\n0 // 곱셈 결괴\n4 // 승수\n5 // 피승수</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>다음은 JMPC가 실행될 때 즉 현재 레지스터가 A의 승수가 양수일 때의 영역이다. 이 부분은 7번라인, 즉 RAM의 6번 주소부터 시작하므로 JMPC의 점프 주소를 6으로 설정한다. 현재 레지스터A에 저장된 값을 STOREA 14로 RAM의 14번 주소에 저장한다. 그리고 곱셈 결과를 저장할 RAM 13번 주소의 값을 LOADA 13으로 레지스터 A에 불러온다. 이 시점에는 아직 계산을 시작하지 않았으므로 0이 저장되어 있을 것이다. 이제 피승수인 5를 더한다. ADD 15 명령어로 RAM의 15번 주소에 있는 피승수를 현재 레지스터A의 값과 더한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">LOADA 14 // A = RAM[14]\nSUB 12 // A -= RAM[12]\nJMPC 6 // CF 활성 시 6번주소로 점프\nLOADA 13 // 13번 주소에 있는 곱셈 결과를 레지스터A에 저장.\nOUT\nHLT\nSTOREA 14\nLOADA 13\nADD 15\n\n\n\n1 // 반복할 때 빼주는 값\n0 // 곱셈 결괴\n4 // 승수\n5 // 피승수</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>방금 구한 덧셈의 결과를 STOREA 13으로 RAM의 13번 주소에 저장한다. 이렇게 첫번째 반복이 완료되어 RAM의 13번 주소에 5가 저장이 된다. 남은 3번의 반복을 위해 JMP 0 명령으로 프로그램 시작 부분으로 돌아간다. 이후 레지스터 A에는 RAM의 14번 주소에 저장된 3이 로드되고 여기서 1을 뺀 2는 아직 양수이므로 다시 RAM의 6번 주소로 이동한다. 반복되는 영역을 수행하면서 RAM의 데이터를 갱신하면서 피승수를 더하는 과정을 반복한다.</p>\n<p>승수가 음수가 되면 JMPC 6명령어가 실행되지 않고 최종결과가 출력되고 프로그램이 종료된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">LOADA 14 // A = RAM[14]\nSUB 12 // A -= RAM[12]\nJMPC 6 // CF 활성 시 6번주소로 점프\nLOADA 13 // 13번 주소에 있는 곱셈 결과를 레지스터A에 저장.\nOUT\nHLT\nSTOREA 14\nLOADA 13\nADD 15\nSTOREA 13\nJMP 0\n\n1 // 반복할 때 빼주는 값\n0 // 곱셈 결괴\n4 // 승수\n5 // 피승수</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>어셈블리 언어 프로그래밍 - 나누기</h2>\n<p>이번에는 나누기 프로그램을 만들어보겠다. 실제 구현 과정은 상세하게 하지 않고 곱셈과 유사하니 결과만 제공하도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-asm line-numbers\"><code class=\"language-asm\">LOADA 15\nSUB 14 // 피제수 -= 제수\nJMPC 7 // 피제수가 제수보다 크면 RAM의 7번 주소로 점프\nJMPZ 7 // 피제수와 제수가 같으면 RAM의 7번 주소로 점프\nLOADA 13\nOUT\nHLT\nSTOREA 15 // 현재 레지스터A의 값을 피제수로 업데이트\nLOADI 1 // 몫 += 1\nADD 13\nSTOREA 13\nJMP 0\n\n0 // 몫\n3 // 제수\n7 // 피제수(결과는 나머지)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","tags":["cs"],"date":"2026-02-18T17:01:27.000Z","image":{"publicURL":"/static/d2f1db1734ce6bdaf587f7d63a88cd29/banner.png"},"series":"컴퓨터 구조론"}}},"pageContext":{"id":"e2337289-9824-55bb-8758-e34fd7c9b3b4"}},
    "staticQueryHashes": ["2580406332","3810308631"]}