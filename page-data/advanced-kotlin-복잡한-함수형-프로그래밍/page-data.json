{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/advanced-kotlin-복잡한-함수형-프로그래밍/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":1},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":3},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"e1e47032-8c58-54ae-9fae-fbb740092d9f","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz41SMUtCURh9P6I9GoTGfkCbtISDEIig7wml2FIimaE0pLVUBkY22NSSSqmEkZHobKavMM0wyBoawppe8YS83/fFe5qKk4cznHu55zuXey5HKoAIkAihy9HADWjsCwT8R3cLEVQMmxlRSISDM3pLJihtwMwSyV+qATq23oihpWJuI0xck7CZa7nHwMdR9ZgRVSrl2lOt/FAmIkmS6s/19FU6m8sOJeMPkTP++OqebW9MsZeMMh4Yb+FNgil5ngzsBZwrTp1eZxbMlnmLa80V3A/2k3+RPnyH74sLofVCVUkCxsBoMlrtVv2c3r/l185oeYG32W2aSY3H63E4Hc3PpmJG9d55b2p6uza+S/wy3OWVdygUbhuNRjQWDR+Fi8ViJBpJXaRip7FSqSSKoizLPTOc5CXDPa3e4M4lxRPU+lb7Axy9qoHSkACgUw9jDBEZYx09WBjXP60SVY74Sf4AtOgKavup5M4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png\"\n        srcset=\"/static/619e6175d83cd70c239721219e3cbc91/6f3f2/banner.png 256w,\n/static/619e6175d83cd70c239721219e3cbc91/01e7c/banner.png 512w,\n/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png 1024w,\n/static/619e6175d83cd70c239721219e3cbc91/c1b63/banner.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>해당 포스팅은 인프런의 <a href=\"https://inf.run/GZfvz\">코틀린 고급편</a> 강의를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>고차 함수와 함수 리터럴</h2>\n<p>이번에는 고차함수의 정의와 함수 리터럴에 대해 살펴보자.</p>\n<p>먼저 고차함수란, 파라미터로 함수를 받거나 함수를 반환하는 함수를 뜻한다. 아래 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>두 수의 덧셈을 하는 아주 간단한 함수이다. 이 함수는 파라미터로 정수 2개를 받고, 정수 1개를 반환한다. 파라미터 타입이나 반환 타입에 함수가 없기 때문에 고차 함수가 아니다. 또한, 이때 add 함수의 타입을 표현해 보면 <code>(Int, Int) -> Int</code>로 나타낼 수 있다. 괄호<code>( () )</code> 안에 있는 2개의 Int가 파라미터를 의미하고, 화살표 <code>(-> )</code> 다음에 있는 Int가 반환 값을 의미한다. 이때 괄호 안의 파라미터 순서 역시 중요하다.</p>\n<p>그러면 아래의 함수를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> op<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1 <span class=\"token punctuation\">,</span>num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 파라미터로 정수 2개와 함수 1개를 받고, 정수 1개를 반환한다. 즉, 파라미터에 함수가 존재하기 때문에 compute 함수는 고차함수이다. 이때 op이라는 파라미터를 보면, <code>(Int, Int) -> Int</code>라는 타입을 가지고 있는데 위에서 살펴보았듯이, 정수 2개를 받아 정수 1개를 반환하는 함수 타입을 의미한다. 반환 타입에도 함수가 들어갈 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">opGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"함수 구현이 되지 않았다\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그러면 이제 고차함수인 <code>compute</code>를 호출해보자. 호출하는 방식은 익명함수 방식과 람다 방식이 존재한다. 한번 코드로 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 람다식을 활용하는 방법</span>\n<span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 익명 함수를 활용하는 방법</span>\n<span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>호출하는 함수 마지막 파라미터에 람다식이 들어가는 경우는 람다식을 함수 호출 부분 바깥으로 뺄 수 있기 때문에 <code>compute(5, 3 { a, b -> a + b })</code>에서 <code>compute(5, 3) { a, b -> a + b }</code>가 되었다. 또한 익명 함수는 우리가 익숙하게 작성하는 함수에서 함수 이름만 빠진 형태인데, 위와 같이 축약 형태로 작성할 수도 있고 아래와 같이 일반적인 형태로 작성할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>익명 함수를 사용할 때 문맥을 통해 파라미터 타입을 추론할 수 있다면, 파라미터 타입 지정을 생략할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 익명 함수를 가장 간단히 만든 방법</span>\n<span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이 람다식과 익명 함수를 합쳐 <strong>함숫값</strong> 또는 <strong>함수 리터럴</strong>이라고 부른다. 리터럴이란, 프로그래밍 언어에서 사용되는 일반적인 용어로 소스 코드의 고정된 값을 나타내는 표기법을 뜻한다. 즉 우리가 고정되어 있는 함수를 나타내기 위해서 람다식 또는 익명 함수를 사용한 것이다.</p>\n<p>그렇다면 람다식과 익명 함수는 어떤 차이가 있을까?! 이 둘은 2가지 차이가 존재한다.</p>\n<ul>\n<li>람다식은 그 어떤 경우에도 반환 타입을 적을 수 없는 반면, 익명 함수는 함수 본문을 사용할 때 반환 타입을 적을 수 있다.</li>\n<li>람다식 안에는 return 을 사용할 수 없지만, 익명 함수 안에는 return 을 사용할 수 있다.</li>\n</ul>\n<p>아래의 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">iterate</span><span class=\"token punctuation\">(</span>numbers<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>number <span class=\"token keyword\">in</span> numbers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>정수로 구성된 <code>List</code>를 받아 주어진 함수를 실행시키는 함수 iterate를 만들었다. 그럼 이 함수를 이용해 1부터 5까지 출력하는데 3은 제외하고 출력하는 코드를 작성해보자. 먼저 익명함수로 구현하면 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">iterate</span><span class=\"token punctuation\">(</span><span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>반면 람다식은 안에 <code>return</code>을 쓸 수 없기에 아래와 같이 해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">iterate</span><span class=\"token punctuation\">(</span><span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> num <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token label symbol\">@iterate</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>바로 점프 라벨을 사용해서 표현하던가 아니면 조건식을 3이 아닐때로 작성해야 한다. 이렇게 람다식에 return이 있는 것을 가리켜 non-local return (비지역적 반환)이라고 부른다.</p>\n<p>그리고 코틀린에는 default parameter가 있는데, 함수 타입의 파라미터 역시 default parameter를 활용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>\n    num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    op<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>혹은 아래와 같이 익명함수를 사용해서 표현이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>\n    num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    op<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token operator\">=</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러면 한번 아래 계산기 예제를 함수형 및 객체지향적으로 표현해보도록 하겠다. 먼저 아래의 계산기 예제를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> oper<span class=\"token operator\">:</span> Char<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">when</span> <span class=\"token punctuation\">(</span>oper<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token char\">'+'</span> <span class=\"token operator\">-></span> num1 <span class=\"token operator\">+</span> num2\n        <span class=\"token char\">'-'</span> <span class=\"token operator\">-></span> num1 <span class=\"token operator\">-</span> num2\n        <span class=\"token char\">'*'</span> <span class=\"token operator\">-></span> num1 <span class=\"token operator\">*</span> num2\n        <span class=\"token char\">'/'</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num2 <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"0으로 나눌 수 없다\"</span></span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                num1 <span class=\"token operator\">/</span> num2\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">else</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Invalid operator: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">oper</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 함수를 객체지향적으로 표현하려면 Enum Class를 이용하는 방식이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Operator</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> oper<span class=\"token operator\">:</span> Char<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> calcFun<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">PLUS</span><span class=\"token punctuation\">(</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">MINUS</span><span class=\"token punctuation\">(</span><span class=\"token char\">'-'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">-</span> b <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">MULTIPLY</span><span class=\"token punctuation\">(</span><span class=\"token char\">'*'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">*</span> b <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">DIVIDE</span><span class=\"token punctuation\">(</span><span class=\"token char\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"0으로 나눌 수 없다\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            a <span class=\"token operator\">/</span> b\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 연산자에게 ‘연산 기능’을 부여하기 위해 Enum class가 함수를 갖도록 할 수 있다. Enum class의 타입을 추가할 때 calcFun의 기본 값을 함수 리터럴, 여기서는 람다를 활용해 넣어주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> oper<span class=\"token operator\">:</span> Operator<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> oper<span class=\"token punctuation\">.</span><span class=\"token function\">calcFun</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Java에서는 비슷한 코드를 구현하기 위해 <code>BiFunction</code> 인터페이스를 활용해야 하지만, Kotlin에서는 함수가 1급 시민이기 때문에 함수 자체를 바로 활용할 수 있다.</p>\n<h2>복잡한 함수 타입과 고차 함수의 단점</h2>\n<p>복잡한 함수 타입과 고차 함수의 단점에 대해 살펴보도록 하자. 아래의 함수들을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> op<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">onGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 함수들은 전부 고차함수들이다. 고차함수이면서 코틀린에서는 함수를 일급시민으로 다루기 때문에 아래와 같이 표현이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 익명함수로 표현</span>\n<span class=\"token keyword\">val</span> compute<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token operator\">=</span> <span class=\"token keyword\">fun</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">,</span> op<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> onGenerator<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 코틀린에는 확장 함수라는 특별한 함수가 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> Int<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>other<span class=\"token operator\">:</span> Long<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">+</span> other<span class=\"token punctuation\">.</span><span class=\"token function\">toInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 확장 함수는 <code>Int</code> 타입을 확장하고 있으며, 확장되는 타입 <code>Int</code>를 수신객체 타입이라고 한다. 그렇다면 이 함수의 함수 타입은 무엇일까? 바로 <code>Int.(Long) -> Int</code>이다. 일반적인 함수 타입인 <code>(파라미터 타임) -> 반환타입</code>에 추가로 수신 객체 타입이 괄호 <code>( () )</code> 앞에 붙게 된다. 이러한 형태를 수신 객체가 있는 함수 리터럴(function literals with receiver)이라고 부르며 여기서 receiver가 수신 객체이다. 수신 객체가 있는 함수 리터럴은 DSL을 만들 때 유용하게 활용된다.</p>\n<p>그럼 확장함수 호출은 어떻게 할까? 총 2가지 방법이 존재한다. <code>invoke()</code> 함수를 사용하거나 일반적인 함수를 호출하듯이 사용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> add <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span>\n\nadd<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또 다른 방법으로는 확장 함수를 사용하는 것처럼 수신 객체 변수로부터 함수를 호출하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token number\">5</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3L</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 고차함수는 컴파일이 되었을 때 어떻게 처리 될까? 아래 코드를 컴파일 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">-></span> a <span class=\"token operator\">*</span> b <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> op<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">,</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">op</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// main 함수 안</span>\n<span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Function2</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// main 함수 바깥</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> num2<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@NotNull</span> <span class=\"token class-name\">Function2</span> op<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Number</span><span class=\"token punctuation\">)</span>op<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 핵심은 Function2 타입이다. 우리가 고차함수에서 파라미터 혹은 반환타입에 함수를 사용하게 되면 코틀린에서는 이 함수를 FunctionN 클래스로 변환한다. 여기서 N은 파라미터 개수이다. 바꿔 말하면 우리가 함수를 변수처럼 사용할 때마다 <code>FunctionN</code> 타입의 객체가 자동으로 생기게 되고 이는 오버헤드로 이어진다. 심지어 고차 함수를 자유롭게 사용하던 중, 우리가 작성한 함수 리터럴이 외부의 가변 변수를 조작한다면 더 복잡해진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\nnum <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">val</span> plusOne <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> num <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>코드에서는 가변 변수 num이 존재하고, 함숫값 plusOne은, 밖에 있는 num에 1을 더해준다. Java에서는 람다에서 가변 변수에 접근할 수 없는 반면, 코틀린에서는 가능한데 그 이유를 아래 컴파일 코드에서 확인해 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token class-name\">Ref<span class=\"token punctuation\">.</span>IntRef</span> num <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Ref<span class=\"token punctuation\">.</span>IntRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnum<span class=\"token punctuation\">.</span>element <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">++</span>num<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Function0</span> plusOne <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Function0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Unit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">++</span>num<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>코드에서 확인할 수 있듯이, Kotlin의 람다식이 가리키는 외부 변수는 <code>Ref</code>라는 객체로 한번 감싸진다. 그래야 <code>plusOne</code> 함수를 표현하는 <code>Function0</code> 객체에서 이 객체에 접근해 값을 변경할 수 있기 때문이다. 한번 정리를 해보겠다.</p>\n<ul>\n<li>고차 함수를 사용하게 되면 <code>FunctionN</code> 타입의 클래스가 만들어지고 인스턴스화되어야 하므로 오버헤드가 발생할 수 있다는 점</li>\n<li>함수에서 변수를 포획할 경우, 해당 변수를 <code>Ref</code>라는 객체로 감싸야하기 때문에 오버헤드가 발생할 수 있다는 점</li>\n</ul>\n<p>결론적으로 고차 함수 사용은 일반적인 함수를 사용하는 것에 비해 성능 부담이 존재하고, 특히 반복문을 고차 함수와 함께 사용하면 익명 클래스가 반복 횟수만큼 인스턴스화될 수 있다. 그렇다면 고차 함수를 사용하지만 성능 부담을 없앨 수는 없을까?! 당연히 존재한다! 그 존재가 바로 inline 함수이다.</p>\n<h2>inline 함수 자세히 살펴보기</h2>\n<p>함수에 <code>inline</code> 키워드를 붙이면, 함수를 호출하는 쪽에 함수 본문을 붙여 넣게 된다. 아래의 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num1<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> num2<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">val</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n    <span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 코드를 컴파일을 하면 <code>add</code> 함수를 호출하는 대신에 덧셈 로직 자체가 <code>main</code> 함수에 적히게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> var10000 <span class=\"token operator\">=</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 inline 함수는 inline 함수가 사용하는 또 다른 함수 역시 인라이닝 시킨다. 아래의 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>\n    times<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>times<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 exec라는 함수를 파라미터로 받는 repeat 함수를 인라이닝 시켰다고 해보자. 위의 코드를 컴파일 하게 되면 아래와 같이 되게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i$iv <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i$iv <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">++</span>i$iv<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Hello World를 출력하는 람다까지 main 함수 안으로 인라인닝 된 것을 확인할 수 있다. 즉, inline 함수는 나 자신뿐 아니라 나와 연관된 다른 함수도 인라이닝 시키는 것이다. 물론, 모든 경우 인라인닝 시키는 것은 아니다. 아래의 코드를 통해 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>\n    times<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>times<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> exec <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 exec 함수는 main 함수 밖에서 불러오는 함수이다. 해당 코드에서는 exec가 어떤 함수인지 판별이 어렵다. 따라서 컴파일을 하면 아래와 같이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NotNull</span> <span class=\"token class-name\">Function0</span> exec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i$iv <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        exec<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// exec을 알 수 없기 때문에 인라이닝 되지 않았다!!</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i$iv <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">++</span>i$iv<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한, 파라미터에 넘어오는 함수를 알 수 있다고 하더라도 강제로 인라이닝 시키지 않을 수 있는데, 함수 앞에 <code>noinline</code> 지시어를 붙여주는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>\n    times<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">noinline</span> exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>times<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>컴파일된 코드를 살펴보면, <code>{ println(\"Hello World\") }</code>라는 함수 리터럴을 알 수 있음에도, <code>noinline</code> 지시어 때문에 <code>Function0</code> 인스턴스가 생겨 이 인스턴스의 <code>invoke()</code> 함수를 직접 호출하게 된다.</p>\n<p>인라인 함수는 인라이닝만 관여하는 것이 아니다! 인라인 함수의 함수 파라미터는 non-local return을 사용할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>num <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span>\n    numbers<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>number <span class=\"token keyword\">in</span> numbers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>원래라면 iterate를 사용할 때 람다식이 아닌 익명 함수를 사용해 return을 썼고, 람다식에서의 return은 금지되었다. 하지만, inline 함수를 사용할 때는 return을 람다식 안에서도 사용할 수 있다. 그리고 return은 가장 가까운 fun 키워드를 갖는 함수를 종료시키기 때문에 출력 결과는 1,2 까지만 나오게 된다. 위에서 본 것처럼, inline 함수의 함수 파라미터를 람다식으로 표현해 non-local return을 쓰게 되면, 예상치 못한 효과가 발생할 수 있다. 또한, inline 함수에서 함수를 받아, 다른 고차 함수에 함수를 전달해야 할 수도 있는데 이럴 때는 non-local return을 쓸 수 없다.</p>\n<p>그러면 non-local return을 금지시키게 할 수 있을까? <code>crossinline</code> 지시어를 사용하면 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>num <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token label symbol\">@iter</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span>\n    numbers<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">crossinline</span> exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>number <span class=\"token keyword\">in</span> numbers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>\n    times<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">noinline</span> exec<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>times<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>똑같은 예제에서, exec 파라미터에 <code>crossinline</code> 지시어만 붙였다. 그렇게 되면 inline 함수였기에 사용 가능했던 람다식 안에서의 non-local return이 다시 사용할 수 없게끔 변경된다.</p>\n<p>인라인 함수뿐 아니라, 인라인 프로퍼티란 것도 있다. 크게 어려운 내용은 아니고, 확장 함수와 비슷한 확장 프로퍼티가 있듯이 인라인 함수와 비슷한 인라인 프로퍼티가 있는 셈이다. 사용 방법 역시 프로퍼티 앞에 <code>inline</code> 키워드를 붙여주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">inline</span> <span class=\"token keyword\">val</span> uppercaseName<span class=\"token operator\">:</span> String\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">uppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>SAM과 reference</h2>\n<p>이번에는 SAM과 reference에 대해 살펴보자.</p>\n<p>SAM이란, Single Abstract Method의 약자로, ‘SAM interface’라고 하면 추상 메소드를 하나만 갖고 있는 인터페이스를 의미한다. 대표적으로 Java의 <code>Runnable</code> 인터페이스가 있다. 이런 SAM interface는 Java에서 특별히 (Java의) 람다를 사용해 인스턴스화할 수 있다. 아래 코드 예시를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">StringFilter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">predicate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>JDK8 이전의 방식처럼 익명 클래스를 사용할 수 있고, JDK8에서 추가된 람다를 이용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// 익명 클래스를 사용하는 방법</span>\n<span class=\"token class-name\">StringFilter</span> filter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">predicate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 람다를 사용하는 방법</span>\n<span class=\"token class-name\">StringFilter</span> filter <span class=\"token operator\">=</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>핵심은, Java에서 SAM interface를 인스턴스화할 때 Java의 람다를 사용할 수 있다는 점이다. 반면, 코틀린에서는 람다를 이용해 SAM을 인스턴스화할 수 없다! 물론 코틀린 1.x 버전일때 이다. 코틀린 2.x에서는 가능하다. 해당 내용은 <a href=\"https://sungbin.kr/%EC%BD%94%ED%8B%80%EB%A6%B0-K2-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/\">블로그</a>를 참조 바란다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// Error: Type mismatch</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>만약 람다를 이용해 SAM을 인스턴스화 하고 싶다면, 람다식 앞에 인터페이스를 붙여줘야 한다. <code>StringFilter { }</code>와 같이 SAM 인터페이스 이름과 람다 조합된 형태를 SAM 생성자라고 부른다. 다행히 이 SAM 생성자를 항상 사용할 필요는 없고, 함수의 파라미터로 SAM 인터페이스를 전달할 때는 그냥 람다를 적어줘도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">consumeFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> s<span class=\"token operator\">:</span> String <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 이렇게 암시적으로 인스턴스화되는 경우는 때때로 의도되지 않는 동작을 불러올 수 있다. 아래의 인터페이스가 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Filter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">predicate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 오버로드가 적용된 consumeFilter 함수가 비슷하게 존재한다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">consumeFilter</span><span class=\"token punctuation\">(</span>filter<span class=\"token operator\">:</span> StringFilter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// StringFilter를 받는다!</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">consumeFilter</span><span class=\"token punctuation\">(</span>filter<span class=\"token operator\">:</span> Filter<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// Filter&lt;T>를 받는다!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 때, <code>consumeFilter({ s: String -> s.startsWith(\"A\") })</code>를 호출하면 어떻게 될까? 정답은 조금 더 구체화된 인터페이스 <code>StringFilter</code>쪽이다. 이론적으로는 StringFilter를 받는 consumeFilter 가 호출될 수도 있고, <code>Filter&#x3C;T></code>를 받는 consumeFilter가 호출될 수도 있지만, 여러 후보가 있을 때 가장 구체화된 타입의 함수가 호출되는 메커니즘을 가지고 있다. 만약, <code>Filter&#x3C;T></code>를 받는 consumeFilter를 호출하고 싶다면 SAM 생성자를 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">consumeFilter</span><span class=\"token punctuation\">(</span>Filter<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>추가적으로 코틀린에서 SAM 인터페이스를 만들고 싶다면 일반 인터페이스에 <code>fun</code> 키워드를 붙여주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token keyword\">interface</span> KStringFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">predicate</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그럼 이 인터페이스가 하나의 추상 메소드를 갖고 있는지 확인받을 수 있게 되고, SAM 생성자를 사용할 수도 있게 된다. 물론, 코틀린에서는 함수 자체를 파라미터에 쉽게 넣을 수 있기 때문에 SAM interface를 사용할 일이 드물긴 하다.</p>\n<p>다음으로 reference에 대해 알아보자. 우리는 함수를 변수에 할당하는 방법으로 익명함수와 람다식 2가지가 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> add1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int <span class=\"token operator\">-></span> a <span class=\"token operator\">+</span> b <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> add2 <span class=\"token operator\">=</span> <span class=\"token keyword\">fun</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그런데 만약 진작 존재하는 함수를 변수에 할당하고 싶다면 더 간단한 방법이 존재한다. 바로, <code>::</code>를 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> add3 <span class=\"token operator\">=</span> <span class=\"token operator\">::</span>add <span class=\"token comment\">// 람다식 또는 익명 함수 대신 ::를 사용할 수 있다!</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이를 호출 가능 참조(callable reference)라고 부른다. 호출 가능 참조를 통해 얻어온 add3는 람다식이나 익명 함수를 사용할 수 있는 곳에 호환된다. 또한, :: 뒤에 add 와 같은 함수 대신 클래스의 이름을 적으면 클래스 생성자에 대한 호출 가능 참조를 획득한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> personConstructor <span class=\"token operator\">=</span> <span class=\"token operator\">::</span>Person\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>프로퍼티에 대해서도 호출 가능 참조를 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> getter <span class=\"token operator\">=</span> Person<span class=\"token operator\">::</span>name<span class=\"token punctuation\">.</span>getter\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 호출 가능 참조는 인스턴스화된 클래스에 대해서도 적용할 수 있고, 확장 함수에 대해서도 적용할 수 있다. 만약 주어진 클래스의 인스턴스 문맥 안에서 호출 가능 참조를 얻어올 경우 이를 바인딩된 호출 가능 참조(bound callable reference)라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> boundingGetter <span class=\"token operator\">=</span> p1<span class=\"token operator\">::</span>name<span class=\"token punctuation\">.</span>getter <span class=\"token comment\">// 바인딩된 호출 가능 참조</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> Int<span class=\"token punctuation\">.</span><span class=\"token function\">addOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> plus <span class=\"token operator\">=</span> Int<span class=\"token operator\">::</span>addOne <span class=\"token comment\">// 확장 함수의 호출 가능 참조</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Java 역시 JDK8부터 메소드 참조나 생성자 참조를 지원한다. Kotlin의 호출 가능 참조와 Java의 호출 가능 참조 차이점은 다음과 같다.</p>\n<ul>\n<li>Kotlin에서 호출 가능 참조를 사용해 나온 결과물은 일급 시민이다.</li>\n<li>Java에서는 호출 가능 참조 결괏값이 <code>Consumer</code>, <code>Supplier</code> 같은 함수형 인터페이스이지만 Kotlin에서는 리플렉션 객체이다.</li>\n</ul>","fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","tags":["kotlin"],"date":"2026-02-20T18:21:27.000Z","image":{"publicURL":"/static/619e6175d83cd70c239721219e3cbc91/banner.png"},"series":"코틀린 고급"}}},"pageContext":{"id":"e1e47032-8c58-54ae-9fae-fbb740092d9f"}},
    "staticQueryHashes": ["2580406332","3810308631"]}