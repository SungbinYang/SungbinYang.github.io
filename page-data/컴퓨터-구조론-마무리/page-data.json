{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/컴퓨터-구조론-마무리/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/컴퓨터-구조론-이론-데이터/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 데이터","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":2},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":3},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"9d9011ff-d297-5920-bc9d-67788d44594d","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVQoz51Sy3LCMAz0/38WkBexE549lQCNEydhptBAz9uRPAYnHdpODxprpUjaVSR0FMBZGc7g47/YuEaME2Uw/dHeZpMHdjVeUzGYFkxhcoVus0Yt5zCZZGxUyj7Fus3KxjOJah4/Z2gbTnB62eJ994pel/g8dbg1xr5di2tdMabc1dRoVwsm4bMU5DhAcuitZcrT2ZIIzSJjdmSEbS7hurF04ctt10uWQpikNnnGzVheEkEnEUymUKcJdBxyUxoyYHgHcWiltQ3O+wKXfcE+SSR5faXxcTzgXOwYU/xyPKDXerDLQUOjJDNwP+FhyuaU5HUQ62aZs0/fftuhC/x2MgPzzude73b4n4N+duBfEs24R4/6hrYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png\"\n        srcset=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/6f3f2/banner.png 256w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/01e7c/banner.png 512w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png 700w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>본 포스팅은 인프런의 <a href=\"https://inf.run/PnrRu\">만들면서 쉽게 배우는 컴퓨터 구조</a>를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>상용 컴퓨터</h2>\n<p>이번 포스팅에는 우리가 만든 컴퓨터와 상용 컴퓨터의 차이점에 대해 알아보겠다. 차이점을 알아보기 전에 먼저 명령어 구조에 따른 종류를 살펴보겠다.</p>\n<p>명령어 구조는 CISC와 RISC가 있는데 CISC는 복잡한 명령어 세트를 사용한다. 대표적으로 데스크톱용 인텔 CPU가 CISC를 사용한다. CISC의 특징은 하나의 명령어로 여러 작업을 수행할 수 있다는 점이다. 이로 인해 RISC보다 명령어가 복잡하고 한 명령어의 실행에 여러 명령어의 사이클이 필요할 수 있다. CISC의 간단한 명령어는 1 사이클로 끝나기도 하지만 곱하기 같은 연산은 여러 명령어 사이클을 통해 하드웨어로 수행된다. 이런 이유로 하드웨어 구조가 복잡해져 가격이 비싸고 전력소모가 많으며 명령어의 길이가 가변적이다.</p>\n<p>반면 RISC는 최소화된 명령어 세트를 사용한다. 주로 스마트폰, 테블릿, 임베디드 시스템에서 사용한다. RISC는 기본적인 연산만 수행하는 단순한 명령어로 구성되어 있다. 명령어의 길이가 고정되어 있고 한 명령어는 한 사이클에 실행된다. 명령어가 단순하므로 하드웨어도 단순해져 가격과 전력소모도 적다. 또한 명령어의 길이가 고정되어 있어서 최적화가 쉽다.</p>\n<p>이렇게 CISC와 RISC의 특징을 알아보았다. 우리가 만든 CPU는 어떤 종류일까? 명령어가 모두 한 사이클에 도니까 RISC이다. 우리가 만든 CPU는 기본 연산만 수행하고 명령어의 길이가 고정된 RISC 방식을 따른다. 이런 이유로 곱하기와 나누기를 할 때 한 줄이 아닌 여러줄의 명령어를 작성했다.</p>\n<p>이제 명령어 구조의 차이를 살펴보았으니 우리가 만든 컴퓨터와 상용 컴퓨터의 다른 차이점들을 알아보자. 가장 먼저 알아볼 차이점은 <strong>파이프라인</strong>이다. 우리가 만든 명령어의 사이클은 step0부터 step4까지 총 5단계였다. 명령어 1개는 1명령어 사이클로 총 5클럭이 소요되었다. 만약 1클럭당 1초가 소요된다면 LOADA 10과 ADD 11 이 2가지 명령을 풀어서 하면 총 10단계가 거쳐질 것이고 10초가 걸릴 것이다.</p>\n<p>오늘날 사용하는 상용 컴퓨터에서 사용하는 파이프라인 기술은 명령어 처리 과정을 여러 단계로 나눠서 동시에 여러 명령어를 처리하는 기술이다. 우리의 명령어를 5단계로 세분화해보겠다. 먼저 명령어 인출의 첫번째 단계는 CO, MI으로 다음 실행할 주소를 MAR에 저장하는 단계이다. 명령어 인출의 두번째 단계는 MAR에 해당하는 RAM 주소에서 명령어를 가져와 IR에 저장하는 것이다. 명령어 인출 단계는 모든 명령어가 공통으로 실행하는 단계이다. 다음으로 명령어 해석 및 실행 단계를 세분화해보겠다. 명령어마다 명령어 해석 및 실행 단계가 다르고 동작도 다르다. 모든 명령어를 분석해서 명령어 해석 및 실행 단계를 잘 나누고 회로를 변경했다고 가정하겠다. 그러면 ADD 11 명령어는 LOAD 10 명령어가 끝난 클럭 5번 주기에서 실행되는 것이 아니라 LOAD 10의 명령어 인출 단계의 두번째 단계가 실행되는 시점에 ADD 11의 명령어 인출 단계가 시작된다. 이렇게 이후에 실행되는 명령어들도 이전 명령어의 인출 마지막 단계가 시작되는 시점에 명령어 인출 단계가 시작되기 때문에 병렬작업으로 처리 속도가 빨라진다. 파이프라인이 없었을 때는 10초정도 걸릴 것이 파이프라인이 있을 때는 6초정도면 되는 셈이다. 상용 컴퓨터는 이런 기술을 사용해 더 효율적인 컴퓨터가 되었다.</p>\n<p>상용 컴퓨터와의 두번째 차이점은 <strong>캐시</strong>이다. 실제 컴퓨터에서는 CPU와 RAM 사이에 물리적인 거리가 존재한다. 이로 인해 CPU가 CPU 내부에 있는 레지스터에 접근하는 속도와 RAM에 접근하는 속도에 차이가 존재한다. CPU의 레지스터는 플립플롭으로 구성되어 있어 매우 빠르지만 RAM은 커패시터로 구성된 상대적으로 느린 DRAM이다. 또한 용량이 큰 RAM의 주소를 계산하는데도 추가 시간이 필요하다. 이러한 이유들로 인해 CPU 내부 레지스터에 접근하는 시간과 RAM에 접근하는 시간에는 상당한 차이가 발생한다. 이러한 속도 차이로 인한 병목현상을 줄이기 위해 CPU 내부나 외부에 캐시라는 메모리를 도입한다. 캐시는 L1, L2, L3로 나눠지는데 숫자가 커질수록 용량은 커지지만 속도는 느려진다. 캐시를 효율적으로 사용하려면 앞으로 필요할 데이터를 미리 캐시에 저장해두는 것이 중요하다.</p>\n<p>RAM은 SRAM과 DRAM으로 나눠진다. SRAM은 속도가 빠르고 용량이 작으며 비용이 비싸서 캐시 메모리로 이용된다. SRAM이 빠른 이유는 트랜지스터와 Latch의 조합으로 만들어졌기 때문이다. 반면 DRAM은 SRAM보다 속도는 느리지만 용량이 크고 가격이 저렴하다. DRAM은 커패시터라는 것을 사용하기 때문에 SRAM보다 속도가 느리고 전력 소비가 많지만 저렴하고 용량이 문제로 메인 메모리로 사용된다. 우리가 만든 RAM은 SRAM이지만 이를 메인 메모리로 활용하였다.</p>\n<p>다음으로 알아 볼 상용 컴퓨터와의 차이점은 <strong>인터럽트</strong>이다. 인터럽트는 CPU가 프로그램을 실행하는 도중에 특별한 예외가 발생했을 때 작업을 중지하고 다른 작업을 처리하는 메커니즘이다. 하드웨어 고장, 외부 신호, 프로그램 실행 오류, 또는 프로그램의 의도적인 요청에 의해 현재 작업이 중단되고 미리 정의된 작업이 수행된다. 이는 상용 컴퓨터 핵심 기능 중 하나이다.</p>","fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","tags":["cs"],"date":"2026-02-18T17:50:27.000Z","image":{"publicURL":"/static/d2f1db1734ce6bdaf587f7d63a88cd29/banner.png"},"series":"컴퓨터 구조론"}}},"pageContext":{"id":"9d9011ff-d297-5920-bc9d-67788d44594d"}},
    "staticQueryHashes": ["2580406332","3810308631"]}