{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/컴퓨터-구조론-이론-보조기억장치/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/coroutine-코루틴의-구성-요소와-원리/"},"timeToRead":13,"frontmatter":{"title":"[코루틴] 코루틴의 구성 요소와 원리","series":"코루틴"}},{"fields":{"slug":"/coroutine-코루틴-기초/"},"timeToRead":15,"frontmatter":{"title":"[코루틴] 코루틴 기초","series":"코루틴"}},{"fields":{"slug":"/운영체제-기초-운영체제-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[운영체제 기초] 운영체제 시작하기","series":"운영체제 기초"}},{"fields":{"slug":"/컴퓨터-구조론-이론-입출력-장치/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 입출력 장치","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-보조기억장치/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 보조기억장치","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-메모리와-캐시-메모리/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 메모리와 캐시 메모리","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-CPU의-성능-향상-기법/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] CPU의 성능 향상 기법","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-코틀린을-더-알아보자/"},"timeToRead":11,"frontmatter":{"title":"[코틀린 고급] 코틀린을 더 알아보자!","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-CPU의-작동-원리/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] CPU의 작동 원리","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-어노테이션과-리플렉션/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 고급] 어노테이션과 리플렉션","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-연산자-오버로딩과-Kotlin-DSL/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 연산자 오버로딩과 Kotlin DSL","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-명령어/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] 명령어","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-데이터/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 데이터","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"운영체제 기초","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":8},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코루틴","totalCount":2},{"fieldValue":"코틀린 고급","totalCount":6},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"edde460d-2dc5-5b4f-9762-61842662b65b","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVQoz51Sy3LCMAz0/38WkBexE549lQCNEydhptBAz9uRPAYnHdpODxprpUjaVSR0FMBZGc7g47/YuEaME2Uw/dHeZpMHdjVeUzGYFkxhcoVus0Yt5zCZZGxUyj7Fus3KxjOJah4/Z2gbTnB62eJ994pel/g8dbg1xr5di2tdMabc1dRoVwsm4bMU5DhAcuitZcrT2ZIIzSJjdmSEbS7hurF04ctt10uWQpikNnnGzVheEkEnEUymUKcJdBxyUxoyYHgHcWiltQ3O+wKXfcE+SSR5faXxcTzgXOwYU/xyPKDXerDLQUOjJDNwP+FhyuaU5HUQ62aZs0/fftuhC/x2MgPzzude73b4n4N+duBfEs24R4/6hrYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png\"\n        srcset=\"/static/d2f1db1734ce6bdaf587f7d63a88cd29/6f3f2/banner.png 256w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/01e7c/banner.png 512w,\n/static/d2f1db1734ce6bdaf587f7d63a88cd29/8c557/banner.png 700w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>본 포스팅은 인프런의 <a href=\"https://inf.run/6vJaw\">개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제</a>를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>다양한 보조기억장치</h2>\n<p>보조기억장치에는 다양한 종류가 존재한다. 그 중에 가장 대표적인 보조기억장치는 하드 디스크와 플래시 메모리이다.</p>\n<h3>하드 디스크</h3>\n<p>하드 디스크는 자기적인 방식으로 데이터를 저장한다. 이 때문에 하드 디스크를 자기 디스크의 일종으로 지칭한다. 하드 드스크에서 실질적으로 데이터가 저장되는 곳은 동그란 원판에 저장이 되는데 이런 동그란 원판을 <strong>플래터</strong>라고 말한다. 하드 디스크는 자기적인 방식으로 데이터를 저장하는데 플래터는 자기 물질로 덮여 있어 수 많은 N극과 S극을 저장한다.</p>\n<p>또한 해당 플래터를 회전시키는 구성 요소를 <strong>스핀들</strong>이라고 한다. 스핀들이 플래터를 돌리는 속도는 분당 회전수를 나타내는 <strong>RPM</strong>이라는 단위로 표현된다.</p>\n<blockquote>\n<p>일반적으로 플래터는 양면으로 이루여져 있는데 양면을 모두 사용한다.</p>\n</blockquote>\n<p>플래터를 대상으로 데이터를 읽고 쓰는 구성 요소는 <strong>헤드</strong>라고 한다. 헤드는 플래터 위에서 미세하게 떠 있는 채로 데이터를 읽고 쓰는 부품이다. 그리고 헤드는 원하는 위치로 헤드를 이동시키는 <strong>디스크 암</strong>에 부착되어 있다.</p>\n<p>플래터는 <strong>트랙</strong>과 <strong>섹터</strong>라는 단위로 데이터를 저장한다. 섹터의 크기는 기본적으로 512byte인데 상황에 따라 4096byte를 차지할 수 있다. 그리고 여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위를 <strong>실린더</strong>라고 부른다. 연속된 정보는 보통 한 실린더에 기록된다. 연속된 정보를 하나의 실린더에 기록하는 이유는 디스크 암을 움직이지 않고 바로 데이터에 접근할 수 있기 때문이다.</p>\n<p>하드 디스크가 저장된 데이터에 접근하는 시간은 크게 <strong>탐색 시간</strong>, <strong>회전 지연</strong>, <strong>전송 시간</strong>으로 나뉜다.</p>\n<ul>\n<li>탐색 시간: 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간</li>\n<li>회전 지연: 헤드가 있는 곳으로 플래터를 회전시키는 시간</li>\n<li>전송 시간: 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간</li>\n</ul>\n<h3>플래시 메모리</h3>\n<p>플래시 메모리란 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장장치를 말한다. 범용성이 넓기에 보조기억장치에만 쓰이지 않고 여러 곳에서 사용이 가능하다. 그래서 주기억장치 중 ROM에도 사용되곤 한다.</p>\n<blockquote>\n<p>플래시 메모리에는 크게 NAND 플래시 메모리와 NOR 플래시 메모리가 있다. NAND 플래시와 NOR 플래시는 각각 NAND 연산을 수행하는 회로와 NOR 연산을 수행하는 회로를 기반으로 만들어진 메모리를 뜻한다. 이 둘 중 대용량 저장 장치로 많이 사용되는 플래시 메모리는 NAND 플래시 메모리이다.</p>\n</blockquote>\n<p>플래시 메모리에는 <strong>셀</strong>이라는 단위가 있다. 셀이란 플래시 메모리에서 데이터를 저장하는 가장 작은 단위이다. 이 셀이 모이고 모여 수 MB, GB, TB 저장장치가 된다. 이 때 하나의 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 나뉜다. 한 셀에 1비트를 저장할 수 있는 플래시 메모리를 <strong>SLC</strong> 타입, 한 셀이 2비트를 저장할 수 있는 플래시 메모리를 <strong>MLC</strong> 타입, 한 셀에 3비트를 저장할 수 있는 플래시 메모리를 <strong>TLC</strong> 타입이라고 한다.</p>\n<p>SLC 타입은 한 셀로 2가지 정보를 표현할 수 있다. 비트의 빠른 입출력이 가능하고 긴 수명이며 용량 대비 고가격이다. MLC 타입은 한 셀로 4개의 정보를 표현하며 대용량에 유리하다. SLC보다 느린 입출력을 가지며 SLC보다 짧은 수명이지만 SLC보다 저렴하여 시중에서 많이 사용된다. TLC 타입은 한 셀로 8가지 정보를 표현하며 대용량에 유리하다. MLC보다 느린 입출력을 가지고 MLC보다 짧은 수명이지만 저렴하며 시중에서 많이 사용된다.</p>\n<p>이제 플래시 메모리의 가장 작은 단위인 셀보다 더 큰 단위를 알아보자. 셀들이 모여 만들어진 단위를 <strong>페이지</strong>, 그리고 페이지가 모여 만들어진 단위를 <strong>블록</strong>이라 한다. 블록이 모여 <strong>플레인</strong>, 플레인이 모여 <strong>다이</strong>가 된다.</p>\n<p>플래시 메모리에서 읽기와 쓰기는 페이지 단위로 이루어진다. 하지만 삭제는 페이지보다 큰 블록 단위로 이루어진다. 이 때 페이지는 3개의 상태를 가질 수 있다. 이는 각각 Free, Valid, Invalid 상태이다. Free 상태는 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태이고, Valid 상태는 이미 유효한 데이터를 저장하고 있는 상태를 의미한다. 그리고 Invalid 상태는 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하고 있는 상태를 의미한다.</p>\n<blockquote>\n<p>플래시 메모리는 하드디스크와 달리 덮어쓰기가 불가능하다.</p>\n</blockquote>\n<p>이렇게 덮어쓰기가 불가능한 이유로 쓰레기 값을 정리할 때 <strong>가비지 컬렉션</strong>을 이용한다. 흔히 GC라고 부르는데 GC는 유효한 페이지들만 새로운 블록으로 복사하고 기존 블록을 삭제하는 방식으로 이루어진다.</p>\n<h2>RAID의 정의와 종류</h2>\n<p>1TB 하드 디스크 4개로 RAID를 구성하면 4TB 하드 디스크 1개의 성능과 안전성을 능가할 수 있다. 그렇다면 RAID가 무엇이고 왜 그런 차이가 발생하는지 알아보자.</p>\n<h3>RAID의 정의</h3>\n<p>HDD와 SSD로 사용되는 기술이 RAID이다. 데이터의 안전성 혹은 높은 성능을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술이다.</p>\n<h3>RAID의 종류</h3>\n<p>여러 개의 하드 디스크나 SSD를 마치 하나의 장치처럼 사용하는 RAID를 구성하는 방법은 여러 가지가 있다. RAID를 구성하는 방법을 RAID 레벨이라고 표현하는데 대표적으로 RAID0, RAID1, RAID2, RAID3, RAID4, RAID5, RAID6가 기본적으로 존재하고 이로부터 파생된 RAID10, RAID50이 존재한다.</p>\n<p>RAID0은 데이터를 단순히 나누어 저장하는 구성방식을 말한다. 각 HDD는 번갈아 가며 데이터를 저장하고 저장되는 데이터가 HDD 개수만큼 나누어 저장을 한다. 이때 마치 줄무늬처럼 분산되어 저장된 데이터를 스트라입이라고 하고 분산하여 저장하는 것을 스트라이핑이라고 한다. RAID0의 장점으로는 I/O 속도가 향상된다는 장점이 있는 반면에 HDD 1개라도 고장이 나면 사용이 안되므로 저장된 정보가 안전하지 않다라는 단점이 존재한다.</p>\n<p>RAID1은 데이터를 쓸 때 원본과 복사본 2군데를 나눠서 작성하는 방식을 뜻한다. 즉 미러링을 하는 기법이다. 장점으로는 복구가 매우 간단하다는 장점이 존재하지만 단점으로는 HDD 개수가 한정되었을 때 사용가능한 용량이 적어진다. 복사본이 만들어지는 용량만큼 사용불가능하며 많은 양의 HDD가 필요하니 비용이 증가한다는 단점이 존재한다.</p>\n<p>RAID4는 RAID1처럼 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장한다. 이를 패리티 비트라고 하는데 패리티를 저장하는 장치를 이용해 다른 장치들의 오류를 검출하고 오류가 있다면 복구하는 기능을 한다.</p>\n<blockquote>\n<p>실제 패리티 비트는 오류 검출만 할 뿐 복구는 불가능하지만 RAID에서는 가능하다.</p>\n</blockquote>\n<p>단점으로는 패리티 디스크에 병목이 발생한다.</p>\n<p>RAID5는 패리티 정보를 분산하여 저장하는 방식을 말한다.</p>\n<p>RAID6는 두 종류의 패리티를 사용하여 RAID5보다 안전하지만 쓰기 기능은 RAID5보다 느리다.</p>\n<p>결론적으로 보면 각 RAID레벨마다 장단점이 존재한다. 어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨은 달라진다. 각 RAID 레벨의 대략적인 구성과 특징을 아는 것이 정말 중요하다.</p>","fields":{"slug":"/컴퓨터-구조론-이론-보조기억장치/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 보조기억장치","tags":["cs"],"date":"2026-02-25T07:18:27.000Z","image":{"publicURL":"/static/d2f1db1734ce6bdaf587f7d63a88cd29/banner.png"},"series":"컴퓨터 구조론 이론"}}},"pageContext":{"id":"edde460d-2dc5-5b4f-9762-61842662b65b"}},
    "staticQueryHashes": ["2580406332","3810308631"]}