{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/코틀린-K2-컴파일러/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/advanced-kotlin-코틀린을-더-알아보자/"},"timeToRead":11,"frontmatter":{"title":"[코틀린 고급] 코틀린을 더 알아보자!","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-CPU의-작동-원리/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] CPU의 작동 원리","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-어노테이션과-리플렉션/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 고급] 어노테이션과 리플렉션","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-연산자-오버로딩과-Kotlin-DSL/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 연산자 오버로딩과 Kotlin DSL","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-명령어/"},"timeToRead":6,"frontmatter":{"title":"[컴퓨터 구조론 이론] 명령어","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/컴퓨터-구조론-이론-데이터/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론 이론] 데이터","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":4},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":6},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"ab631c20-449c-5aeb-951f-926060192271","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz41SMUtCURh9P6I9GoTGfkCbtISDEIig7wml2FIimaE0pLVUBkY22NSSSqmEkZHobKavMM0wyBoawppe8YS83/fFe5qKk4cznHu55zuXey5HKoAIkAihy9HADWjsCwT8R3cLEVQMmxlRSISDM3pLJihtwMwSyV+qATq23oihpWJuI0xck7CZa7nHwMdR9ZgRVSrl2lOt/FAmIkmS6s/19FU6m8sOJeMPkTP++OqebW9MsZeMMh4Yb+FNgil5ngzsBZwrTp1eZxbMlnmLa80V3A/2k3+RPnyH74sLofVCVUkCxsBoMlrtVv2c3r/l185oeYG32W2aSY3H63E4Hc3PpmJG9d55b2p6uza+S/wy3OWVdygUbhuNRjQWDR+Fi8ViJBpJXaRip7FSqSSKoizLPTOc5CXDPa3e4M4lxRPU+lb7Axy9qoHSkACgUw9jDBEZYx09WBjXP60SVY74Sf4AtOgKavup5M4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png\"\n        srcset=\"/static/619e6175d83cd70c239721219e3cbc91/6f3f2/banner.png 256w,\n/static/619e6175d83cd70c239721219e3cbc91/01e7c/banner.png 512w,\n/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png 1024w,\n/static/619e6175d83cd70c239721219e3cbc91/c1b63/banner.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1>Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것</h1>\n<h2>들어가며</h2>\n<p>최근 Kotlin 버전을 1.8에서 2.3으로 올리고 코드를 작성하던 중, 흥미로운 현상을 발견했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>StringFilter</code>는 Java에서 정의한 함수형 인터페이스다. 그런데 이 코드가 <strong>Kotlin 1.8에서는 컴파일 에러</strong>가 나고, <strong>Kotlin 2.3에서는 정상 동작</strong>한다. 분명 Java SAM 인터페이스에 람다를 직접 대입하는 건 안 되는 걸로 알고 있었는데, 왜 지금은 되는 걸까?</p>\n<p>이 글에서는 이 동작 변화의 원인을 파헤쳐 보고, Kotlin의 SAM 변환이 어떻게 발전해 왔는지를 정리해 본다.</p>\n<hr>\n<h2>SAM 변환이란?</h2>\n<p>SAM은 <strong>Single Abstract Method</strong>의 약자로, 추상 메서드가 하나만 있는 인터페이스를 말한다. Java 8에서는 이런 인터페이스를 <strong>함수형 인터페이스(Functional Interface)</strong> 라고 부르며, <code>@FunctionalInterface</code> 어노테이션을 붙여 명시한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">StringFilter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Java에서는 이런 함수형 인터페이스 타입이 기대되는 곳에 람다를 직접 전달할 수 있다. 이걸 <strong>SAM 변환(SAM Conversion)</strong> 이라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Java — 람다를 함수형 인터페이스 타입 변수에 직접 대입</span>\n<span class=\"token class-name\">StringFilter</span> filter <span class=\"token operator\">=</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Kotlin도 Java와의 상호운용성을 위해 SAM 변환을 지원한다. 하지만 그 지원 범위는 Kotlin 버전에 따라 달랐다.</p>\n<hr>\n<h2>Kotlin에서의 SAM 변환 역사</h2>\n<h3>Kotlin 1.0 — Java SAM에 대한 기본 지원</h3>\n<p>Kotlin은 1.0부터 Java의 함수형 인터페이스에 대한 SAM 변환을 지원했다. 다만 지원되는 위치가 제한적이었다.</p>\n<p><strong>함수 인자로 전달할 때</strong>는 SAM 변환이 적용됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Java 메서드: void applyFilter(StringFilter filter) { ... }</span>\n\n<span class=\"token comment\">// ✅ 함수 파라미터로 전달 — SAM 변환 적용</span>\napplyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>SAM 생성자(SAM Constructor)</strong> 를 명시적으로 사용하는 것도 가능했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// ✅ SAM 생성자 — 항상 가능</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 <strong>변수 타입을 명시하고 람다를 직접 대입하는 것</strong>은 불가능했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// ❌ Kotlin 1.x에서 컴파일 에러!</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Type mismatch: inferred type is (String) -> Boolean but StringFilter was expected</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h3>Kotlin 1.4 — Kotlin 인터페이스에 대한 SAM 변환 (<code>fun interface</code>)</h3>\n<p>Kotlin 1.4에서는 <code>fun interface</code> 키워드가 도입되면서, <strong>Kotlin에서 정의한 인터페이스</strong>에도 SAM 변환을 사용할 수 있게 됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin 1.4 이전에는 이게 안 됐음</span>\n<span class=\"token keyword\">interface</span> MyFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> f <span class=\"token operator\">=</span> MyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ❌ 컴파일 에러</span>\n\n<span class=\"token comment\">// Kotlin 1.4부터 fun interface로 선언하면 SAM 변환 가능</span>\n<span class=\"token keyword\">fun</span> <span class=\"token keyword\">interface</span> MyFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> f <span class=\"token operator\">=</span> MyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ✅ OK</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 시점에서 많은 개발자들이 \"Kotlin에서 SAM 변환이 안 된다\"고 알고 있던 것은, 바로 이 <strong>Kotlin 인터페이스에 대한 SAM 변환</strong>이 안 됐던 것을 기억하는 경우가 많다.</p>\n<p>하지만 <code>fun interface</code> 도입 이후에도, <strong>타입을 명시한 변수에 람다를 직접 대입하는 것</strong>(<code>val f: Type = { ... }</code>)은 Java SAM, Kotlin <code>fun interface</code> 모두에서 불가능했다. 1.4에서 가능해진 것은 SAM 생성자(<code>val f = MyFilter { ... }</code>)와 함수 인자 전달 위치에서의 SAM 변환이었다.</p>\n<h3>Kotlin 2.0 — K2 컴파일러와 SAM 변환의 확장</h3>\n<p>그리고 마침내 <strong>Kotlin 2.0</strong>에서 K2 컴파일러가 정식 도입되면서, 이 제한이 해제됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// ✅ Kotlin 2.0+ (K2 컴파일러)에서는 이것도 된다!</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<hr>\n<h2>구 컴파일러는 왜 이걸 허용하지 않았을까?</h2>\n<p>이유를 이해하려면, 구 컴파일러의 타입 추론 방식을 알아야 한다.</p>\n<h3>구 컴파일러의 타입 추론 흐름</h3>\n<p>구 컴파일러가 <code>val filter: StringFilter = { s -> s.startsWith(\"A\") }</code>를 만났을 때, 내부적으로 다음과 같은 순서로 처리했다.</p>\n<ol>\n<li><strong>우변의 람다 타입 결정</strong>: <code>{ s -> s.startsWith(\"A\") }</code>는 <code>(String) -> Boolean</code> 함수 타입으로 추론된다.</li>\n<li><strong>좌변의 기대 타입 확인</strong>: <code>StringFilter</code>는 Java 인터페이스 타입이다.</li>\n<li><strong>타입 호환성 검사</strong>: <code>(String) -> Boolean</code> ≠ <code>StringFilter</code> → <strong>Type mismatch!</strong></li>\n</ol>\n<p>구 컴파일러는 SAM 변환을 <strong>특정 위치에서만</strong> 적용했다.</p>\n<ul>\n<li>함수 호출 시 인자로 전달하는 위치 ✅</li>\n<li>SAM 생성자를 명시적으로 사용하는 경우 ✅</li>\n<li>변수 대입 위치 ❌</li>\n</ul>\n<p>이는 구 컴파일러의 프론트엔드 아키텍처가 <code>BindingContext</code>라는 거대한 해시 테이블 기반 구조에 의존했기 때문이다. 타입 정보를 단계별로 수집하고 저장하는 이 방식에서는, 대입문의 기대 타입 정보를 람다의 타입 추론 단계에 자연스럽게 전달하기가 구조적으로 어려웠다.</p>\n<h3>SAM 생성자로 우회하는 방법</h3>\n<p>그래서 구 컴파일러에서는 SAM 생성자를 사용해 명시적으로 변환을 지시해야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// SAM 생성자 — 컴파일러에게 \"이 람다를 StringFilter로 변환해라\"고 명시적으로 알려줌</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>SAM 생성자는 컴파일러가 자동으로 생성하는 팩토리 함수처럼 동작하며, 람다를 해당 인터페이스의 구현체로 명시적으로 감싸준다.</p>\n<hr>\n<h2>K2 컴파일러는 무엇이 다른가?</h2>\n<h3>완전히 새로 작성된 프론트엔드</h3>\n<p>K2 컴파일러는 Kotlin 컴파일러의 <strong>프론트엔드(의미 분석, 호출 해석, 타입 추론 담당)</strong> 를 완전히 새로 작성한 것이다. 공식 문서에서는 이를 다음과 같이 설명한다.</p>\n<blockquote>\n<p>With the arrival of the K2 compiler, the Kotlin frontend has been completely rewritten and features a new, more efficient architecture. The fundamental change the new compiler brings is the use of one unified data structure that contains more semantic information.</p>\n<p>— <a href=\"https://kotlinlang.org/docs/k2-compiler-migration-guide.html\">K2 compiler migration guide</a></p>\n</blockquote>\n<h3>구 컴파일러 vs K2 컴파일러의 내부 구조 차이</h3>\n<p><strong>구 컴파일러</strong>는 <strong>PSI(Program Structure Interface)</strong> 와 <strong>BindingContext</strong>에 의존했다.</p>\n<ul>\n<li>PSI는 소스 파일의 모든 정보를 담고 있어 크고 복잡하다.</li>\n<li>BindingContext는 바인딩 정보를 거대한 해시 맵 구조로 관리했다.</li>\n<li>변수 참조 하나를 조회하는 데도 여러 번의 맵 조회가 필요했다.</li>\n</ul>\n<p><strong>K2 컴파일러</strong>는 <strong>FIR(Frontend Intermediate Representation)</strong> 이라는 새로운 트리 기반 데이터 구조를 사용한다.</p>\n<ul>\n<li>FIR은 PSI보다 간결하면서도 더 많은 의미 정보를 포함한다.</li>\n<li>트리 노드에서 직접 값을 접근하므로 해시 맵 조회가 필요 없다.</li>\n<li>타입 추론 시 기대 타입 정보가 자연스럽게 하위 노드로 전파된다.</li>\n</ul>\n<h3>K2에서의 타입 추론 흐름</h3>\n<p>K2 컴파일러가 동일한 코드를 처리할 때는 이렇게 동작한다.</p>\n<ol>\n<li><strong>좌변의 기대 타입 확인</strong>: <code>StringFilter</code>가 기대된다.</li>\n<li><strong>기대 타입 정보를 우변으로 전파</strong>: 람다에게 \"네가 <code>StringFilter</code>가 되어야 한다\"는 정보를 전달한다.</li>\n<li><strong>SAM 변환 가능 여부 확인</strong>: <code>StringFilter</code>는 Java 함수형 인터페이스이고, 람다의 시그니처가 <code>filter(String): Boolean</code>과 일치한다.</li>\n<li><strong>암시적 SAM 변환 적용</strong>: 람다를 <code>StringFilter</code> 구현체로 자동 변환한다. ✅</li>\n</ol>\n<p>핵심 차이는 K2 컴파일러가 <strong>기대 타입(Expected Type) 정보를 적극적으로 활용</strong>한다는 것이다. 구 컴파일러에서는 대입문의 기대 타입 정보가 SAM 변환 판단에 반영되지 않았지만, K2에서는 <strong>기대 타입이 SAM 인터페이스인 모든 위치</strong>에서 암시적 SAM 변환이 가능해졌다.</p>\n<hr>\n<h2>실제 코드로 보는 동작 차이</h2>\n<p>다양한 케이스에서 Kotlin 1.x와 2.0+의 동작 차이를 정리해 보자.</p>\n<h3>Case 1: 변수 대입</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Java</span>\n<span class=\"token annotation builtin\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> StringFilter <span class=\"token punctuation\">{</span>\n    boolean <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Kotlin 1.x</th>\n<th>Kotlin 2.0+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>❌ Type mismatch</td>\n<td>✅ 정상 컴파일</td>\n</tr>\n</tbody>\n</table>\n<h3>Case 2: SAM 생성자 (명시적)</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Kotlin 1.x</th>\n<th>Kotlin 2.0+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 정상</td>\n<td>✅ 정상</td>\n</tr>\n</tbody>\n</table>\n<h3>Case 3: 함수 인자로 전달</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">applyFilter</span><span class=\"token punctuation\">(</span>filter<span class=\"token operator\">:</span> StringFilter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n\napplyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Kotlin 1.x</th>\n<th>Kotlin 2.0+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 정상</td>\n<td>✅ 정상</td>\n</tr>\n</tbody>\n</table>\n<h3>Case 4: 함수 반환 타입으로 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">createFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> StringFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Kotlin 1.x</th>\n<th>Kotlin 2.0+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>❌ Type mismatch</td>\n<td>✅ 정상 컴파일</td>\n</tr>\n</tbody>\n</table>\n<h3>Case 5: 컬렉션 내에서 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// ❌ Kotlin 2.0+에서도 컴파일 에러!</span>\n<span class=\"token keyword\">val</span> filters<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>StringFilter<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Kotlin 1.x</th>\n<th>Kotlin 2.0+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>❌ Type mismatch</td>\n<td>❌ Type mismatch</td>\n</tr>\n</tbody>\n</table>\n<p>K2에서 이 코드를 컴파일하면 다음과 같은 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Argument type mismatch: actual type is\n'Function1&lt;ERROR CLASS: Unknown return lambda parameter type,\nERROR CLASS: Unknown return lambda parameter type>',\nbut 'StringFilter' was expected.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>ERROR CLASS: Unknown return lambda parameter type</code>이라는 메시지가 핵심이다. 변수의 기대 타입이 <code>List&#x3C;StringFilter></code>이더라도, 그 타입 정보가 <code>listOf</code>의 제네릭 타입 파라미터 <code>T</code>를 거쳐 개별 람다 인자까지 전파되지 않는다. 컴파일러 입장에서는 람다의 파라미터 타입조차 알 수 없는 상태이므로, SAM 변환 이전에 람다 자체의 타입 추론부터 실패하는 것이다.</p>\n<p>이 경우에는 SAM 생성자를 명시적으로 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// ✅ SAM 생성자를 명시적으로 사용</span>\n<span class=\"token keyword\">val</span> filters<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>StringFilter<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span>\n    StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Case 4에서 볼 수 있듯이, K2 컴파일러는 변수 대입이나 함수 반환 등 <strong>기대 타입이 직접적으로 전달되는 위치</strong>에서 SAM 변환을 적용한다. 하지만 제네릭 함수의 타입 파라미터를 거쳐야 하는 간접적인 위치에서는 여전히 명시적인 SAM 생성자가 필요하다.</p>\n<hr>\n<h2>Java SAM vs Kotlin <code>fun interface</code> — 헷갈리기 쉬운 포인트</h2>\n<p>SAM 변환과 관련해서 Java SAM 인터페이스와 Kotlin <code>fun interface</code>를 혼동하는 경우가 많다. 이 둘의 SAM 변환 지원 역사를 정리하면 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Java 함수형 인터페이스</th>\n<th>Kotlin <code>fun interface</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>함수 인자 전달</strong></td>\n<td>Kotlin 1.0+ ✅</td>\n<td>Kotlin 1.4+ ✅</td>\n</tr>\n<tr>\n<td><strong>SAM 생성자</strong></td>\n<td>Kotlin 1.0+ ✅</td>\n<td>Kotlin 1.4+ ✅</td>\n</tr>\n<tr>\n<td><strong>변수 대입 (<code>val f: Type = { ... }</code>)</strong></td>\n<td>Kotlin 2.0+ ✅ (K2)</td>\n<td>Kotlin 2.0+ ✅ (K2)</td>\n</tr>\n</tbody>\n</table>\n<p>흥미로운 점은, Java 함수형 인터페이스뿐만 아니라 <strong>Kotlin <code>fun interface</code>에서도 변수 대입(<code>val f: Type = { ... }</code>) 방식은 1.x에서 동작하지 않았다</strong>는 것이다. 1.4에서 <code>fun interface</code>가 도입됐을 때 지원된 것은 SAM 생성자(<code>val f = MyFilter { ... }</code>)와 함수 인자 전달이었고, 타입을 명시한 변수에 람다를 직접 대입하는 방식은 K2 컴파일러에서야 가능해졌다. 결국 K2의 기대 타입 기반 SAM 변환 확장은 Java SAM과 Kotlin <code>fun interface</code> 모두에 적용된 범용적인 개선인 셈이다.</p>\n<hr>\n<h2>K2 컴파일러가 가져온 그 외의 개선들</h2>\n<p>K2 컴파일러는 SAM 변환 외에도 다양한 타입 추론 개선을 포함하고 있다. 대표적인 것들을 간략히 살펴보자.</p>\n<h3>스마트 캐스트 개선 — 조건을 변수에 담아도 스마트 캐스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Cat <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">purr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Purr purr\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">petAnimal</span><span class=\"token punctuation\">(</span>animal<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> isCat <span class=\"token operator\">=</span> animal <span class=\"token keyword\">is</span> Cat\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isCat<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Kotlin 2.0+: isCat 변수를 통해 animal이 Cat으로 스마트 캐스트됨</span>\n        <span class=\"token comment\">// Kotlin 1.x: 스마트 캐스트 불가 — 변수에 담긴 조건식은 인식하지 못했음</span>\n        animal<span class=\"token punctuation\">.</span><span class=\"token function\">purr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> kitty <span class=\"token operator\">=</span> <span class=\"token function\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">petAnimal</span><span class=\"token punctuation\">(</span>kitty<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 출력: Purr purr</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Kotlin 1.x에서는 <code>animal is Cat</code>을 <code>if</code> 조건에 직접 작성해야만 스마트 캐스트가 동작했다. 조건을 변수에 담으면 컴파일러가 그 의미를 추적하지 못했기 때문이다. K2에서는 로컬 변수에 담긴 타입 검사 결과도 추적하여 스마트 캐스트에 반영한다.</p>\n<h3>논리 OR 연산자와 스마트 캐스트 — 공통 상위 타입으로 캐스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Status <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Signal received\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> Postponed <span class=\"token operator\">:</span> Status\n<span class=\"token keyword\">interface</span> Declined <span class=\"token operator\">:</span> Status\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">signalCheck</span><span class=\"token punctuation\">(</span>signalStatus<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>signalStatus <span class=\"token keyword\">is</span> Postponed <span class=\"token operator\">||</span> signalStatus <span class=\"token keyword\">is</span> Declined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Kotlin 2.0+: 공통 상위 타입인 Status로 스마트 캐스트</span>\n        <span class=\"token comment\">// Kotlin 1.x: Any로 캐스트되어 signal() 호출 불가</span>\n        signalStatus<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> status <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> Postponed <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">signalCheck</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 출력: Signal received</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Kotlin 1.x에서는 <code>||</code>로 타입 검사를 조합하면 <code>Any</code>로 캐스트됐기 때문에, <code>signal()</code> 메서드를 호출하려면 추가 타입 체크가 필요했다. K2에서는 <code>Postponed</code>와 <code>Declined</code>의 공통 상위 타입인 <code>Status</code>로 자동 캐스트된다.</p>\n<h3>인라인 함수 내에서의 스마트 캐스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Processor <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Processing...\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">inlineAction</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">nextProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> Processor <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">runProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> processor<span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    inlineAction <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>processor <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// Kotlin 2.0+: processor가 non-null로 스마트 캐스트</span>\n            <span class=\"token comment\">// Kotlin 1.x: safe call 필요 (processor?.process())</span>\n            processor<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        processor <span class=\"token operator\">=</span> <span class=\"token function\">nextProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> processor\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> <span class=\"token function\">runProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Result: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">result</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Kotlin 1.x에서는 인라인 함수에 전달된 람다 내부에서 외부 <code>var</code> 변수의 null 검사가 스마트 캐스트에 반영되지 않았다. 람다가 나중에 호출될 수 있다는 가능성 때문이었는데, K2에서는 인라인 함수의 람다가 제자리에서 호출(callsInPlace)된다는 점을 인식하여 안전하게 스마트 캐스트를 적용한다.</p>\n<hr>\n<p>이런 개선들은 모두 K2 컴파일러의 새로운 FIR 기반 아키텍처에서 기대 타입과 타입 상태 정보가 더 넓은 범위로 전파되기 때문에 가능해진 것이다.</p>\n<hr>\n<h2>실무에서의 영향과 마이그레이션 팁</h2>\n<h3>기존 코드는 그대로 동작한다</h3>\n<p>K2 컴파일러로 업그레이드해도, 기존에 SAM 생성자를 사용하던 코드는 그대로 동작한다. 호환성 걱정 없이 업그레이드할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 이전 방식 — K2에서도 정상 동작</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3>새 코드는 더 간결하게 작성 가능</h3>\n<p>K2 환경에서는 기대 타입이 명확한 상황에서 SAM 생성자 없이 람다를 직접 대입할 수 있어, 코드가 더 간결해진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// K2에서 가능한 새로운 방식</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3>하위 호환성을 고려한다면</h3>\n<p>만약 라이브러리를 작성하거나, Kotlin 1.x 환경도 지원해야 한다면 SAM 생성자를 명시적으로 사용하는 것이 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 하위 호환성이 필요한 경우 — SAM 생성자 사용</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<hr>\n<h2>마무리</h2>\n<p>정리하면, Kotlin 1.x에서 Java 함수형 인터페이스 타입 변수에 람다를 직접 대입하지 못했던 것은 <strong>구 컴파일러의 타입 추론 한계</strong> 때문이었다. Kotlin 2.0에서 도입된 <strong>K2 컴파일러</strong>는 프론트엔드를 완전히 재작성하면서 기대 타입 기반의 SAM 변환을 더 넓은 범위에서 지원하게 됐고, 그 결과 이전에 불가능했던 코드가 자연스럽게 동작하게 됐다.</p>\n<p>이처럼 K2 컴파일러는 단순한 성능 개선뿐만 아니라, 개발자가 \"당연히 될 것 같은데 안 됐던\" 코드들을 실제로 동작하게 만들어 주는 의미 있는 변화를 가져왔다. Kotlin 2.0 이상을 사용하고 있다면, 이런 개선된 타입 추론의 혜택을 누려보자.</p>\n<hr>\n<h2>참고 자료</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/k2-compiler-migration-guide.html\">K2 compiler migration guide — Kotlin 공식 문서</a></li>\n<li><a href=\"https://kotlinlang.org/docs/whatsnew20.html\">What's new in Kotlin 2.0.0 — Kotlin 공식 문서</a></li>\n<li><a href=\"https://kotlinlang.org/docs/fun-interfaces.html\">Functional (SAM) interfaces — Kotlin 공식 문서</a></li>\n<li><a href=\"https://kotlinlang.org/docs/compatibility-guide-20.html\">Compatibility guide for Kotlin 2.0 — Kotlin 공식 문서</a></li>\n</ul>","fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":11,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","tags":["트러블 슈팅"],"date":"2026-02-20T18:58:27.000Z","image":{"publicURL":"/static/619e6175d83cd70c239721219e3cbc91/banner.png"},"series":"트러블 슈팅"}}},"pageContext":{"id":"ab631c20-449c-5aeb-951f-926060192271"}},
    "staticQueryHashes": ["2580406332","3810308631"]}