{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/코틀린-K2-컴파일러/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":7,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","series":"트러블 슈팅"}},{"fields":{"slug":"/advanced-kotlin-복잡한-함수형-프로그래밍/"},"timeToRead":12,"frontmatter":{"title":"[코틀린 고급] 복잡한 함수형 프로그래밍","series":"코틀린 고급"}},{"fields":{"slug":"/advanced-kotlin-지연과-위임/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 지연과 위임","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-이론-컴퓨터-구조-시작하기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론 이론] 컴퓨터 구조 시작하기","series":"컴퓨터 구조론 이론"}},{"fields":{"slug":"/advanced-kotlin-제네릭/"},"timeToRead":18,"frontmatter":{"title":"[코틀린 고급] 제네릭","series":"코틀린 고급"}},{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 구조론 이론","totalCount":1},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 고급","totalCount":3},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":3},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"ab631c20-449c-5aeb-951f-926060192271","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz41SMUtCURh9P6I9GoTGfkCbtISDEIig7wml2FIimaE0pLVUBkY22NSSSqmEkZHobKavMM0wyBoawppe8YS83/fFe5qKk4cznHu55zuXey5HKoAIkAihy9HADWjsCwT8R3cLEVQMmxlRSISDM3pLJihtwMwSyV+qATq23oihpWJuI0xck7CZa7nHwMdR9ZgRVSrl2lOt/FAmIkmS6s/19FU6m8sOJeMPkTP++OqebW9MsZeMMh4Yb+FNgil5ngzsBZwrTp1eZxbMlnmLa80V3A/2k3+RPnyH74sLofVCVUkCxsBoMlrtVv2c3r/l185oeYG32W2aSY3H63E4Hc3PpmJG9d55b2p6uza+S/wy3OWVdygUbhuNRjQWDR+Fi8ViJBpJXaRip7FSqSSKoizLPTOc5CXDPa3e4M4lxRPU+lb7Axy9qoHSkACgUw9jDBEZYx09WBjXP60SVY74Sf4AtOgKavup5M4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png\"\n        srcset=\"/static/619e6175d83cd70c239721219e3cbc91/6f3f2/banner.png 256w,\n/static/619e6175d83cd70c239721219e3cbc91/01e7c/banner.png 512w,\n/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png 1024w,\n/static/619e6175d83cd70c239721219e3cbc91/c1b63/banner.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>들어가며</h2>\n<p>최근 Kotlin 버전을 1.8에서 2.3으로 올리고 코드를 작성하던 중, 흥미로운 현상을 발견했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>function\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>StringFilter</code>는 Java에서 정의한 함수형 인터페이스다. 그런데 이 코드가 Kotlin 1.8에서는 컴파일 에러가 나고, Kotlin 2.3에서는 정상 동작한다. 분명 Java SAM 인터페이스에 람다를 직접 대입하는 건 안 되는 걸로 알고 있었는데, 왜 지금은 되는 걸까? 이 글에서는 이 동작 변화의 원인을 파헤쳐 보고, Kotlin의 SAM 변환이 어떻게 발전해 왔는지를 정리해 본다.</p>\n<h2>SAM 변환이란?</h2>\n<p>SAM은 Single Abstract Method의 약자로, 추상 메서드가 하나만 있는 인터페이스를 말한다. Java 8에서는 이런 인터페이스를 함수형 인터페이스(Functional Interface) 라고 부르며, <code>@FunctionalInterface</code> 어노테이션을 붙여 명시한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">StringFilter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Java에서는 이런 함수형 인터페이스 타입이 기대되는 곳에 람다를 직접 전달할 수 있다. 이걸 SAM 변환(SAM Conversion) 이라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Java — 람다를 함수형 인터페이스 타입 변수에 직접 대입</span>\n<span class=\"token class-name\">StringFilter</span> filter <span class=\"token operator\">=</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Kotlin도 Java와의 상호운용성을 위해 SAM 변환을 지원한다. 하지만 그 지원 범위는 Kotlin 버전에 따라 달랐다.</p>\n<h2>Kotlin에서의 SAM 변환 역사</h2>\n<h3>Kotlin 1.0 — Java SAM에 대한 기본 지원</h3>\n<p>Kotlin은 1.0부터 Java의 함수형 인터페이스에 대한 SAM 변환을 지원했다. 다만 지원되는 위치가 제한적이었다. 함수 인자로 전달할 때는 SAM 변환이 적용됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Java 메서드: void applyFilter(StringFilter filter) { ... }</span>\n\n<span class=\"token comment\">// 함수 파라미터로 전달 — SAM 변환 적용</span>\napplyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>SAM 생성자(SAM Constructor) 를 명시적으로 사용하는 것도 가능했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// SAM 생성자 — 항상 가능</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 변수 타입을 명시하고 람다를 직접 대입하는 것은 불가능했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin 1.x에서 컴파일 에러!</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Type mismatch: inferred type is (String) -> Boolean but StringFilter was expected</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h2>Kotlin 1.4 — Kotlin 인터페이스에 대한 SAM 변환 (fun interface)</h2>\n<p>Kotlin 1.4에서는 <code>fun interface</code> 키워드가 도입되면서, Kotlin에서 정의한 인터페이스에도 SAM 변환을 사용할 수 있게 됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin 1.4 이전에는 이게 안 됐음</span>\n<span class=\"token keyword\">interface</span> MyFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> f <span class=\"token operator\">=</span> MyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 컴파일 에러</span>\n\n<span class=\"token comment\">// Kotlin 1.4부터 fun interface로 선언하면 SAM 변환 가능</span>\n<span class=\"token keyword\">fun</span> <span class=\"token keyword\">interface</span> MyFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> f <span class=\"token operator\">=</span> MyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// OK</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 시점에서 많은 개발자들이 \"Kotlin에서 SAM 변환이 안 된다\"고 알고 있던 것은, 바로 이 Kotlin 인터페이스에 대한 SAM 변환이 안 됐던 것을 기억하는 경우가 많다. 하지만 <code>fun interface</code> 도입 이후에도, Java 함수형 인터페이스에 대해 변수에 람다를 직접 대입하는 것은 여전히 불가능했다.</p>\n<h2>Kotlin 2.0 — K2 컴파일러와 SAM 변환의 확장</h2>\n<p>그리고 마침내 Kotlin 2.0에서 K2 컴파일러가 정식 도입되면서, 이 제한이 해제됐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin 2.0+ (K2 컴파일러)에서는 이것도 된다!</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2>구 컴파일러는 왜 이걸 허용하지 않았을까?</h2>\n<p>이유를 이해하려면, 구 컴파일러의 타입 추론 방식을 알아야 한다.</p>\n<h3>구 컴파일러의 타입 추론 흐름</h3>\n<p>구 컴파일러가 <code>val filter: StringFilter = { s -> s.startsWith(\"A\") }</code>를 만났을 때, 내부적으로 다음과 같은 순서로 처리했다.</p>\n<ul>\n<li>우변의 람다 타입 결정: <code>{ s -> s.startsWith(\"A\") }</code>는 <code>(String) -> Boolean</code> 함수 타입으로 추론된다.</li>\n<li>좌변의 기대 타입 확인: <code>StringFilter</code>는 Java 인터페이스 타입이다.</li>\n<li>타입 호환성 검사: <code>(String) -> Boolean</code> != <code>StringFilter</code> -> Type mismatch!</li>\n</ul>\n<p>구 컴파일러는 SAM 변환을 특정 위치에서만 적용했다.</p>\n<ul>\n<li>함수 호출 시 인자로 전달하는 위치</li>\n<li>SAM 생성자를 명시적으로 사용하는 경우</li>\n</ul>\n<p>이는 구 컴파일러의 프론트엔드 아키텍처가 BindingContext라는 거대한 해시 테이블 기반 구조에 의존했기 때문이다. 타입 정보를 단계별로 수집하고 저장하는 이 방식에서는, 대입문의 기대 타입 정보를 람다의 타입 추론 단계에 자연스럽게 전달하기가 구조적으로 어려웠다.</p>\n<h3>SAM 생성자로 우회하는 방법</h3>\n<p>그래서 구 컴파일러에서는 SAM 생성자를 사용해 명시적으로 변환을 지시해야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// SAM 생성자 — 컴파일러에게 \"이 람다를 StringFilter로 변환해라\"고 명시적으로 알려줌</span>\n<span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>SAM 생성자는 컴파일러가 자동으로 생성하는 팩토리 함수처럼 동작하며, 람다를 해당 인터페이스의 구현체로 명시적으로 감싸준다.</p>\n<h2>K2 컴파일러는 무엇이 다른가?</h2>\n<h3>완전히 새로 작성된 프론트엔드</h3>\n<p>K2 컴파일러는 Kotlin 컴파일러의 프론트엔드(의미 분석, 호출 해석, 타입 추론 담당) 를 완전히 새로 작성한 것이다. 공식 문서에서는 이를 다음과 같이 설명한다.</p>\n<blockquote>\n<p>With the arrival of the K2 compiler, the Kotlin frontend has been completely rewritten and features a new, more efficient architecture. The fundamental change the new compiler brings is the use of one unified data structure that contains more semantic information.</p>\n<p>— K2 compiler migration guide</p>\n</blockquote>\n<h3>구 컴파일러 vs K2 컴파일러의 내부 구조 차이</h3>\n<p>구 컴파일러는 PSI(Program Structure Interface) 와 BindingContext에 의존했다.</p>\n<ul>\n<li>PSI는 소스 파일의 모든 정보를 담고 있어 크고 복잡하다.</li>\n<li>BindingContext는 바인딩 정보를 거대한 해시 맵 구조로 관리했다.</li>\n<li>변수 참조 하나를 조회하는 데도 여러 번의 맵 조회가 필요했다.</li>\n</ul>\n<p>K2 컴파일러는 FIR(Frontend Intermediate Representation) 이라는 새로운 트리 기반 데이터 구조를 사용한다.</p>\n<ul>\n<li>FIR은 PSI보다 간결하면서도 더 많은 의미 정보를 포함한다.</li>\n<li>트리 노드에서 직접 값을 접근하므로 해시 맵 조회가 필요 없다.</li>\n<li>타입 추론 시 기대 타입 정보가 자연스럽게 하위 노드로 전파된다.</li>\n</ul>\n<h3>K2에서의 타입 추론 흐름</h3>\n<p>K2 컴파일러가 동일한 코드를 처리할 때는 이렇게 동작한다.</p>\n<ul>\n<li>좌변의 기대 타입 확인: <code>StringFilter</code>가 기대된다.</li>\n<li>기대 타입 정보를 우변으로 전파: 람다에게 \"네가 <code>StringFilter</code>가 되어야 한다\"는 정보를 전달한다.</li>\n<li>SAM 변환 가능 여부 확인: <code>StringFilter</code>는 Java 함수형 인터페이스이고, 람다의 시그니처가 <code>filter(String): Boolean</code>과 일치한다.</li>\n<li>암시적 SAM 변환 적용: 람다를 <code>StringFilter</code> 구현체로 자동 변환한다.</li>\n</ul>\n<p>핵심 차이는 K2 컴파일러가 기대 타입(Expected Type) 정보를 적극적으로 활용한다는 것이다. 구 컴파일러에서는 대입문의 기대 타입 정보가 SAM 변환 판단에 반영되지 않았지만, K2에서는 기대 타입이 SAM 인터페이스인 모든 위치에서 암시적 SAM 변환이 가능해졌다.</p>\n<h2>실제 코드로 보는 동작 차이</h2>\n<p>다양한 케이스에서 Kotlin 1.x와 2.0+의 동작 차이를 정리해 보자.</p>\n<h3>Case 1: 변수 대입</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Java</span>\n<span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">StringFilter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// Kotlin</span>\n<span class=\"token keyword\">val</span> filter<span class=\"token operator\">:</span> StringFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<ul>\n<li>Kotlin 1.x: Type mismatch</li>\n<li>Kotlin 2.0+: 정상 컴파일</li>\n</ul>\n<h3>SAM 생성자 (명시적)</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> StringFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<ul>\n<li>Kotlin 1.x: 정상 컴파일</li>\n<li>Kotlin 2.0+: 정상 컴파일</li>\n</ul>\n<h3>Case 3: 함수 인자로 전달</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">applyFilter</span><span class=\"token punctuation\">(</span>filter<span class=\"token operator\">:</span> StringFilter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n\napplyFilter <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Kotlin 1.x: 정상 컴파일</li>\n<li>Kotlin 2.0+: 정상 컴파일</li>\n</ul>\n<h3>Case 4: 함수 반환 타입으로 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">createFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> StringFilter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> s <span class=\"token operator\">-></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"A\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Kotlin 1.x: Type mismatch</li>\n<li>Kotlin 2.0+: 정상 컴파일</li>\n</ul>\n<p>Case 4에서 볼 수 있듯이, K2 컴파일러는 변수 대입뿐만 아니라 기대 타입이 명확한 모든 위치에서 SAM 변환을 적용한다.</p>\n<p>흥미로운 점은, Kotlin의 <code>fun interface</code>는 1.4부터 변수 대입에서의 SAM 변환을 지원했지만, Java 함수형 인터페이스는 2.0이 되어서야 동일한 동작이 가능해졌다는 것이다. 이는 Kotlin <code>fun interface</code>의 SAM 변환이 Kotlin 컴파일러 내부에서 직접 처리되는 반면, Java SAM의 경우 Java-Kotlin 상호운용 레이어를 통해 처리되기 때문이다. K2 컴파일러에서 이 상호운용 레이어의 타입 추론까지 개선되면서 비로소 일관된 동작이 가능해진 것이다.</p>\n<h2>K2 컴파일러가 가져온 그 외의 개선들</h2>\n<p>K2 컴파일러는 SAM 변환 외에도 다양한 타입 추론 개선을 포함하고 있다. 대표적인 것들을 간략히 살펴보자.</p>\n<h3>스마트 캐스트 개선</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Cat <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">purr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Purr purr\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">petAnimal</span><span class=\"token punctuation\">(</span>animal<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> isCat <span class=\"token operator\">=</span> animal <span class=\"token keyword\">is</span> Cat\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isCat<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Kotlin 2.0+: isCat 변수를 통해 animal이 Cat으로 스마트 캐스트됨</span>\n        <span class=\"token comment\">// Kotlin 1.x: 스마트 캐스트 불가 — 변수에 담긴 조건식은 인식하지 못했음</span>\n        animal<span class=\"token punctuation\">.</span><span class=\"token function\">purr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> kitty <span class=\"token operator\">=</span> <span class=\"token function\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">petAnimal</span><span class=\"token punctuation\">(</span>kitty<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 출력: Purr purr</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>논리 OR 연산자와 스마트 캐스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Status <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Signal received\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> Postponed <span class=\"token operator\">:</span> Status\n<span class=\"token keyword\">interface</span> Declined <span class=\"token operator\">:</span> Status\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">signalCheck</span><span class=\"token punctuation\">(</span>signalStatus<span class=\"token operator\">:</span> Any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>signalStatus <span class=\"token keyword\">is</span> Postponed <span class=\"token operator\">||</span> signalStatus <span class=\"token keyword\">is</span> Declined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Kotlin 2.0+: 공통 상위 타입인 Status로 스마트 캐스트</span>\n        <span class=\"token comment\">// Kotlin 1.x: Any로 캐스트되어 signal() 호출 불가</span>\n        signalStatus<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> status <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> Postponed <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">signalCheck</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 출력: Signal received</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>인라인 함수 내에서의 스마트 캐스트</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Processor <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Processing...\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">inlineAction</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">nextProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> Processor <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">runProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> processor<span class=\"token operator\">:</span> Processor<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    inlineAction <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>processor <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// Kotlin 2.0+: processor가 non-null로 스마트 캐스트</span>\n            <span class=\"token comment\">// Kotlin 1.x: safe call 필요 (processor?.process())</span>\n            processor<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        processor <span class=\"token operator\">=</span> <span class=\"token function\">nextProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> processor\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> <span class=\"token function\">runProcessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Result: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">result</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>마무리</h2>\n<p>정리하면, Kotlin 1.x에서 Java 함수형 인터페이스 타입 변수에 람다를 직접 대입하지 못했던 것은 구 컴파일러의 타입 추론 한계 때문이었다. Kotlin 2.0에서 도입된 K2 컴파일러는 프론트엔드를 완전히 재작성하면서 기대 타입 기반의 SAM 변환을 더 넓은 범위에서 지원하게 됐고, 그 결과 이전에 불가능했던 코드가 자연스럽게 동작하게 됐다. 이처럼 K2 컴파일러는 단순한 성능 개선뿐만 아니라, 개발자가 \"당연히 될 것 같은데 안 됐던\" 코드들을 실제로 동작하게 만들어 주는 의미 있는 변화를 가져왔다. Kotlin 2.0 이상을 사용하고 있다면, 이런 개선된 타입 추론의 혜택을 누려보자.</p>\n<blockquote>\n<p>참고자로</p>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/k2-compiler-migration-guide.html\">https://kotlinlang.org/docs/k2-compiler-migration-guide.html</a></li>\n<li><a href=\"https://kotlinlang.org/docs/whatsnew20.html\">https://kotlinlang.org/docs/whatsnew20.html</a></li>\n<li><a href=\"https://kotlinlang.org/docs/fun-interfaces.html\">https://kotlinlang.org/docs/fun-interfaces.html</a></li>\n<li><a href=\"https://kotlinlang.org/docs/compatibility-guide-20.html\">https://kotlinlang.org/docs/compatibility-guide-20.html</a>.</li>\n</ul>\n</blockquote>","fields":{"slug":"/코틀린-K2-컴파일러/"},"timeToRead":7,"frontmatter":{"title":"Kotlin 1.x에서 안 되던 코드가 2.0에서 된다? — K2 컴파일러가 바꿔놓은 Java SAM 변환의 모든 것","tags":["트러블 슈팅"],"date":"2026-02-20T18:58:27.000Z","image":{"publicURL":"/static/619e6175d83cd70c239721219e3cbc91/banner.png"},"series":"트러블 슈팅"}}},"pageContext":{"id":"ab631c20-449c-5aeb-951f-926060192271"}},
    "staticQueryHashes": ["2580406332","3810308631"]}