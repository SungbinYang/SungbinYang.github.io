{
    "componentChunkName": "component---src-template-post-tsx",
    "path": "/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/컴퓨터-구조론-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 구조론] 마무리","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-기계어-어셈블리어/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 기계어와 어셈블리어","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기-제어장치/"},"timeToRead":9,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기 - 제어장치","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-제어장치가-없는-컴퓨터/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 구조론] 제어장치가 없는 컴퓨터","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-메모리-만들기/"},"timeToRead":12,"frontmatter":{"title":"[컴퓨터 구조론] 메모리 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-CPU-만들기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 구조론] CPU 만들기: 산술논리연산장치(ALU)","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-기초가-되는-하드웨어-만들기/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터의 기초가 되는 하드웨어 만들기","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-비트/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 구조론] 비트","series":"컴퓨터 구조론"}},{"fields":{"slug":"/Redis-캐싱-전략/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 캐싱 전략","series":"redis 기본"}},{"fields":{"slug":"/Redis-사용법-익히기/"},"timeToRead":4,"frontmatter":{"title":"[Redis] Redis 사용법 익히기","series":"redis 기본"}},{"fields":{"slug":"/Redis-기본-개념/"},"timeToRead":1,"frontmatter":{"title":"[Redis] Redis 기본 개념","series":"redis 기본"}},{"fields":{"slug":"/Gradle-Introduction/"},"timeToRead":2,"frontmatter":{"title":"[Gradle] Introduction","series":"gradle"}},{"fields":{"slug":"/intellij-플러그인/"},"timeToRead":2,"frontmatter":{"title":"[IntelliJ] 플러그인","series":"IntelliJ"}},{"fields":{"slug":"/intellij-Git-Github/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] Git&Github","series":"IntelliJ"}},{"fields":{"slug":"/intellij-디버깅/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 디버깅","series":"IntelliJ"}},{"fields":{"slug":"/intellij-리팩토링/"},"timeToRead":6,"frontmatter":{"title":"[IntelliJ] 리팩토링","series":"IntelliJ"}},{"fields":{"slug":"/intellij-자동완성/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 자동완성","series":"IntelliJ"}},{"fields":{"slug":"/intellij-검색/"},"timeToRead":4,"frontmatter":{"title":"[IntelliJ] 검색","series":"IntelliJ"}},{"fields":{"slug":"/css/"},"timeToRead":8,"frontmatter":{"title":"[프론트엔드] css","series":"프론트엔드"}},{"fields":{"slug":"/Javascript/"},"timeToRead":18,"frontmatter":{"title":"[프론트엔드] Javascript","series":"프론트엔드"}},{"fields":{"slug":"/HTML/"},"timeToRead":10,"frontmatter":{"title":"[프론트엔드] HTML","series":"프론트엔드"}},{"fields":{"slug":"/프론트엔드에-대해/"},"timeToRead":6,"frontmatter":{"title":"[프론트엔드] 프론트엔드에 대해","series":"프론트엔드"}},{"fields":{"slug":"/백엔드-개발자에-의한-백엔드-개발자를-위한-프론트엔드/"},"timeToRead":2,"frontmatter":{"title":"[프론트엔드] 백엔드 개발자에 의한, 백엔드 개발자를 위한 프론트엔드","series":"프론트엔드"}},{"fields":{"slug":"/intellij-포커스/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 포커스","series":"IntelliJ"}},{"fields":{"slug":"/intellij-코드-Edit/"},"timeToRead":8,"frontmatter":{"title":"[IntelliJ] 코드 Edit","series":"IntelliJ"}},{"fields":{"slug":"/intellij-소개/"},"timeToRead":3,"frontmatter":{"title":"[IntelliJ] 소개","series":"IntelliJ"}},{"fields":{"slug":"/컴퓨터-구조론-불-대수/"},"timeToRead":13,"frontmatter":{"title":"[컴퓨터 구조론] 불 대수","series":"컴퓨터 구조론"}},{"fields":{"slug":"/지속-성장-가능한-소프트웨어를-만들어가는-방법/"},"timeToRead":7,"frontmatter":{"title":"[소프트웨어] 지속 성장 가능한 소프트웨어를 만들어가는 방법","series":"소프트웨어"}},{"fields":{"slug":"/향로와-함께하는-챌린지-후기/"},"timeToRead":2,"frontmatter":{"title":"향로와 함께하는 추석 완강 챌린지","series":"일상"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구성-요소/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구성 요소","series":"컴퓨터 구조론"}},{"fields":{"slug":"/컴퓨터-구조론-컴퓨터-구조-개요/"},"timeToRead":5,"frontmatter":{"title":"[컴퓨터 구조론] 컴퓨터 구조 개요","series":"컴퓨터 구조론"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-FP/"},"timeToRead":16,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 FP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-자료구조-소개와-마무리/"},"timeToRead":2,"frontmatter":{"title":"[컴퓨터 기초] 자료구조 소개와 마무리","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-프로그래밍-맛보기/"},"timeToRead":4,"frontmatter":{"title":"[컴퓨터 기초] 프로그래밍 맛보기","series":"컴퓨터 기초"}},{"fields":{"slug":"/코틀린-상속-간-주의-점/"},"timeToRead":2,"frontmatter":{"title":"코틀린 상속 간 주의점","series":"트러블 슈팅"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-OOP/"},"timeToRead":23,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 OOP","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-운영체제/"},"timeToRead":8,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 운영체제","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-코드를-제어하는-방법/"},"timeToRead":13,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 코드를 제어하는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-넓고-얕은-컴퓨터-구조/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 넓고 얕은 컴퓨터 구조","series":"컴퓨터 기초"}},{"fields":{"slug":"/컴퓨터-기초-컴공-이론을-위한-기초체력-다지기/"},"timeToRead":7,"frontmatter":{"title":"[컴퓨터 기초] 컴공 이론을 위한 기초체력 다지기","series":"컴퓨터 기초"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-코틀린에서-변수와-타입-연산자를-다루는-방법/"},"timeToRead":14,"frontmatter":{"title":"[코틀린 입문] 코틀린에서 변수와 타입, 연산자를 다루는 방법","series":"코틀린 입문"}},{"fields":{"slug":"/java-to-kotlin-starter-guide-강의-소개/"},"timeToRead":2,"frontmatter":{"title":"[코틀린 입문] 강의 소개","series":"코틀린 입문"}},{"fields":{"slug":"/컴퓨터-기초-학습에-앞서-본-강의-소개/"},"timeToRead":3,"frontmatter":{"title":"[컴퓨터 기초] 학습에 앞서 본 강의 소개","series":"컴퓨터 기초"}},{"fields":{"slug":"/중요한-것은-포기하지-않는-마음/"},"timeToRead":3,"frontmatter":{"title":"2025년 1분기 회고(feat. 중요한 것은 포기하지 않는 마음)","series":"일상 이야기"}},{"fields":{"slug":"/2024년-주니어-개발자-회고록/"},"timeToRead":3,"frontmatter":{"title":"2024년 주니어 개발자 회고록","series":"일상 이야기"}},{"fields":{"slug":"/WDD/"},"timeToRead":1,"frontmatter":{"title":"WDD(Why-Driven-Development)","series":"생각정리"}},{"fields":{"slug":"/내가-개발자-커리어를-시작한-이유/"},"timeToRead":4,"frontmatter":{"title":"내가 개발자 커리어를 시작한 이유","series":"일상"}},{"fields":{"slug":"/블로그-이관-및-회고/"},"timeToRead":3,"frontmatter":{"title":"블로그 이관 및 회고","series":"일상 이야기"}},{"fields":{"slug":"/Spring-Boot-3.2.x-더-이상-바이트코드를-구문-분석하여-매개변수-이름을-추론하려고-시도하지-않스/"},"timeToRead":3,"frontmatter":{"title":"Spring Boot 3.2.x 더 이상 바이트코드를 구문 분석하여 매개변수 이름을 추론하려고 시도하지 않습니다.","series":"트러블 슈팅"}},{"fields":{"slug":"/라떼-개발자/"},"timeToRead":2,"frontmatter":{"title":"라떼 개발자","series":"생각정리"}},{"fields":{"slug":"/2023년-주니어-개발자-회고록/"},"timeToRead":5,"frontmatter":{"title":"2023년 주니어 개발자 회고록","series":"일상 이야기"}}],"group":[{"fieldValue":"IntelliJ","totalCount":9},{"fieldValue":"gradle","totalCount":1},{"fieldValue":"redis 기본","totalCount":3},{"fieldValue":"생각정리","totalCount":2},{"fieldValue":"소프트웨어","totalCount":1},{"fieldValue":"일상","totalCount":2},{"fieldValue":"일상 이야기","totalCount":4},{"fieldValue":"컴퓨터 구조론","totalCount":11},{"fieldValue":"컴퓨터 기초","totalCount":6},{"fieldValue":"코틀린 입문","totalCount":6},{"fieldValue":"트러블 슈팅","totalCount":2},{"fieldValue":"프론트엔드","totalCount":5}]},"markdownRemark":{"id":"9feb3248-2bdc-5b3d-8615-93c9a0efa9ea","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz41SMUtCURh9P6I9GoTGfkCbtISDEIig7wml2FIimaE0pLVUBkY22NSSSqmEkZHobKavMM0wyBoawppe8YS83/fFe5qKk4cznHu55zuXey5HKoAIkAihy9HADWjsCwT8R3cLEVQMmxlRSISDM3pLJihtwMwSyV+qATq23oihpWJuI0xck7CZa7nHwMdR9ZgRVSrl2lOt/FAmIkmS6s/19FU6m8sOJeMPkTP++OqebW9MsZeMMh4Yb+FNgil5ngzsBZwrTp1eZxbMlnmLa80V3A/2k3+RPnyH74sLofVCVUkCxsBoMlrtVv2c3r/l185oeYG32W2aSY3H63E4Hc3PpmJG9d55b2p6uza+S/wy3OWVdygUbhuNRjQWDR+Fi8ViJBpJXaRip7FSqSSKoizLPTOc5CXDPa3e4M4lxRPU+lb7Axy9qoHSkACgUw9jDBEZYx09WBjXP60SVY74Sf4AtOgKavup5M4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"banner\"\n        title=\"banner\"\n        src=\"/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png\"\n        srcset=\"/static/619e6175d83cd70c239721219e3cbc91/6f3f2/banner.png 256w,\n/static/619e6175d83cd70c239721219e3cbc91/01e7c/banner.png 512w,\n/static/619e6175d83cd70c239721219e3cbc91/2bef9/banner.png 1024w,\n/static/619e6175d83cd70c239721219e3cbc91/c1b63/banner.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>해당 포스팅은 인프런의 <a href=\"https://inf.run/yusn4\">자바 개발자를 위한 코틀린 입문(Java to Kotlin Starter Guide)</a> 강의를 참조하여 작성한 글입니다.</p>\n</blockquote>\n<h2>코틀린 이모저모</h2>\n<h3>Type Alias와 as import</h3>\n<p>우리가 코딩을 하다보면 긴 클래스 이름이나 함수 타입이 있을 때 축약하거나 더 좋은 이름으로 쓰고 싶을 때가 있다. 아래와 같은 코드가 있다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">filterFruits</span><span class=\"token punctuation\">(</span>\n    fruits<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    filter<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Fruit<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Boolean<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> fruits\n        <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>filter<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>filter의 타입을 보면 <code>(Fruit) -> Boolean</code>으로 <code>Fruit</code> 타입을 인자로 받아서 <code>Boolean</code>형을 반환하는 함수 타입니다. 하지만 이게 너무 길다고 느껴질 때가 있을 것이다. 이를 위해 코틀린에서는 type alias라는 기능을 제공해준다. 그리고 아래와 같이 변형해서 사용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">typealias</span> FruitFilter <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Fruit<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Boolean\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">filterFruits</span><span class=\"token punctuation\">(</span>\n    fruits<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    filter<span class=\"token operator\">:</span> FruitFilter<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> fruits\n        <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>filter<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한, List나 Map과 같이 이름 긴 클래스를 컬렉션으로 사용할 때도 간단히 줄일 수 있다.</p>\n<p>아래의 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19<span class=\"token punctuation\">.</span>a\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">printHelloWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19<span class=\"token punctuation\">.</span>b\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">printHelloWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>서로 다른 두 패키지에 같은 이름의 함수를 쓰고 싶을 때는 어떻게 해야할까? 자바 같은 경우에는 둘 중 하나는 import를 해서 사용하고 나머지는 full package명을 적어줘야 했다. 하지만 코틀린에서는 as import라는 기능을 아래와 같이 제공해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19\n\n<span class=\"token keyword\">import</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>printHelloWorld <span class=\"token keyword\">as</span> printHelloWorldA\n<span class=\"token keyword\">import</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">.</span>printHelloWorld <span class=\"token keyword\">as</span> printHelloWorldB\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printHelloWorldA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">printHelloWorldB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>as import</code>란, 어떤 클래스나 함수를 임포트할 때 이름을 바꾸는 기능이다.</p>\n<h3>구조분해와 componentN 함수</h3>\n<p>구조분해란, 복합적인 값을 분해하여 여러 변수를 한번에 초기화 하는 과정을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19\n\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같은 data class가 있다고 하자. 이것을 구조분해 기능을 이용하면 아래와 같이 여러 변수를 받을 수 있다. 단, 순서는 선언된 필드 순서이니 주의 바란다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> person <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"양성빈\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> person\n\n<span class=\"token comment\">// val name = person.component1()</span>\n<span class=\"token comment\">// val age = person.component2()</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러면 이런 구조분해는 어떻게 가능해진걸까? 사실, 구조분해를 하려면 <code>componentN</code> 함수를 정의해줘야 하는데 data class는 해당 함수를 자동으로 만들어주기에 우리가 특별한 설정 없이 사용 가능한 것이다. 만약 일반 클래스로 하려면 아래와 같이 정의를 해서 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">package</span> me<span class=\"token punctuation\">.</span>sungbin<span class=\"token punctuation\">.</span>lec19\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">Student</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">operator</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">component1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> name\n\n    <span class=\"token keyword\">operator</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">component2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> age\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> student <span class=\"token operator\">=</span> <span class=\"token function\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"양성빈\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> <span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">,</span> studentAge<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> student</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<p><code>componentN</code> 함수는 일종의 연산자처럼 사용하기에 <code>operator</code>라는 키워드를 붙여줘야 한다.</p>\n</blockquote>\n<p>또한, 우리가 이전에 반복문이나 컬렉션 반복문을 하면서 배웠던 아래 코드에 key, value를 한번에 받는 것도 구조분해 기능 중 하나이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> map<span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">key</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">value</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h3>Jump와 Label</h3>\n<p>우리는 반복문 시간에 <code>return</code>, <code>break</code>와 <code>continue</code>를 배우지 않았다. 코틀린에서도 자바와 같이 해당 기능을 사용할 수 있다.</p>\n<ul>\n<li><code>return</code>: 기본적으로 가장 가까운 enclosing function 또는 익명 함수로 값이 반환된다.</li>\n<li><code>break</code>: 가장 가까운 루프가 제거된다.</li>\n<li><code>continue</code>: 가장 가까운 루프를 다음 step으로 보낸다.</li>\n</ul>\n<p>해당 기능 전부 코틀린에서도 사용 가능하다. 단, <code>forEach</code> 안에서는 사용이 불가능하다. 그런데도 만약 <code>forEach</code>문에서 사용하고 싶다면 아래와 같이 해주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\">run <span class=\"token punctuation\">{</span>\n    numbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> number <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token label symbol\">@run</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>해당 기능은 <code>break</code>에 대한 기능을 표현한 것이고 아래는 <code>continue</code>에 대해 작성한 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\">run <span class=\"token punctuation\">{</span>\n    numbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> number <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token label symbol\">@forEach</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>하지만, <code>break</code>, <code>continue</code> 기능을 쓸 때는 가급적 익숙한 for문을 사용하자! 왜냐하면 가독성 자체가 매우 떨어지기 때문이다.</p>\n<p>코틀린에는 라벨이라는 기능을 제공한다. 특정 expression에 **라벨이름@**를 붙여 하나의 라벨로 간주하고 <code>break</code>, <code>continue</code>, <code>return</code> 기능을 사용하면 된다. 바로 아래와 같이 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token label symbol\">loop@</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token label symbol\">@loop</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">i</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">j</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>하지만 이것은 매우 가독성이 떨어진다. 위의 로직상 대강 보면 <code>break</code>문을 통해서 가장 가까운 for문을 빠져 나갈 것 같지만 사실상 전체 반복문이 종료된다. 그래서 라벨을 사용한 Jump 기능은 사용하지 않는 것을 추천한다!</p>\n<h3>TakeIf와 TakeUnless</h3>\n<p>코틀린에서는 메서드 체이닝을 위한 특이한 함수들을 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getNumberOrNull</span><span class=\"token punctuation\">(</span>number<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">null</span> <span class=\"token keyword\">else</span> number\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위와 같은 함수가 있다고 하자. 주어진 인자의 수가 0이하면 null을 반환하고 아니면 그 값을 반환하는 로직이다. 이것을 <code>takeIf</code>로 변경하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getNumberOrNullV2</span><span class=\"token punctuation\">(</span>number<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> number<span class=\"token punctuation\">.</span><span class=\"token function\">takeIf</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code>takeIf</code>는 주어진 조건을 만족하면 그 값을, 그렇지 않으면 null을 반환한다. 그 반대되는 함수도 있는데 바로 <code>takeUnless</code>이다. 주어진 조건을 만족하지 않으면 그 값이 반환되고 그렇지 않으면 null이 반환된다.</p>\n<h2>코틀린의 scope function</h2>\n<h3>scope function이란 무엇인가?</h3>\n<p>코틀린에서는 scope function이라는 것이 존재한다. scope function이란 무엇일까? scope의 사전적 의미는 영역을 뜻하고, function은 함수를 뜻한다. 즉, scope function은 일시적인 영역을 형성하는 함수를 뜻한다. 그러면 아랭 코드가 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">printPersonV1</span><span class=\"token punctuation\">(</span>person<span class=\"token operator\">:</span> Person<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>person <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 코드를 scope function을 활용하여 변경해보자! 리팩토링을 하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">printPersonV2</span><span class=\"token punctuation\">(</span>person<span class=\"token operator\">:</span> Person<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    person<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 코드를 해석해보면 person이 null일 경우를 대비하여 safe call을 통하여 <code>let</code>이라는 scope function을 호출하였고 람다식으로 해당 로직을 작성하였다. 방금 설명했지만 <code>let</code>은 scope function 종류 중 하나이다. <code>let</code>은 람다식을 받아서 람다 결과를 반환하는 확장 함수 형태의 scope function이다. 또한, 람다 안에서 수신 객체를 접근할 때는 <code>it</code>라는 키워드를 사용해줘야 한다.</p>\n<p>다시 scope function의 정의로 돌아와서 정리해보면 scope function은 람다를 사용해 일시적인 영역을 만들고 코드를 더 간결하게 만들거나 method chaining에 활용하는 함수를 scope function이라고 한다.</p>\n<h3>scope function 분류</h3>\n<p>절대 외우지 말자! 필요할 때 찾아보면 되니 지금은 가볍게 정리한다는 마음으로 살펴보자.</p>\n<p>scope function에는 <code>let</code>, <code>run</code>, <code>also</code>, <code>apply</code>, <code>with</code>가 존재한다. 여기서 <code>with</code>를 제외한 나머지는 전부 확장함수이다. 그럼 좀 더 살펴보자.</p>\n<p><code>let</code>과 <code>run</code>은 람다의 결과를 반환하며, <code>also</code>와 <code>apply</code>는 객체 그 자체를 반환한다. 한번 예시를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> value1 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n    it<span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> value2 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">run</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> value3 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">also</span> <span class=\"token punctuation\">{</span>\n    it<span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> value4 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>value1과 value2는 age의 타입이 반환된다. 즉, value1과 value2는 age의 값이 들어가게 되는 건다. 반면, value3과 value4는 해당 객체 타입 즉, person 객체가 들어가게 된다. 이렇게 차이가 존재한다. 또 하나의 차이가 있는데 한번 살펴보자. value1과 value3는 수신 객체를 가리킬 때 <code>it</code> 키워드로 가리키고 value2와 value4는 수신 객체를 <code>this</code>로 가리킨다.</p>\n<p>그러면 <code>it</code>와 <code>this</code>의 차이를 살펴보자.</p>\n<ul>\n<li><code>this</code>: 생략이 가능한 대신, 다른 이름을 붙일 수 없다.</li>\n<li><code>it</code>: 생략이 불가능한 대신, 다른 이름을 붙일 수 있다.</li>\n</ul>\n<p>아래의 코드를 보면 더 이해가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> value2 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">run</span> <span class=\"token punctuation\">{</span>\n    age\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> value3 <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">also</span> <span class=\"token punctuation\">{</span> p <span class=\"token operator\">-></span>\n    p<span class=\"token punctuation\">.</span>age\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>왜 이런 차이가 발생할까? 궁금하지 않나? 한번 <code>run</code>과 <code>also</code>의 내부 함수를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token label symbol\">@kotlin</span><span class=\"token punctuation\">.</span>internal<span class=\"token punctuation\">.</span>InlineOnly\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> R<span class=\"token operator\">></span> T<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span> T<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> R<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> R <span class=\"token punctuation\">{</span>\n    contract <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callsInPlace</span><span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">,</span> InvocationKind<span class=\"token punctuation\">.</span>EXACTLY_ONCE<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token label symbol\">@kotlin</span><span class=\"token punctuation\">.</span>internal<span class=\"token punctuation\">.</span>InlineOnly\n<span class=\"token annotation builtin\">@SinceKotlin</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"1.1\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> T<span class=\"token punctuation\">.</span><span class=\"token function\">also</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token punctuation\">{</span>\n    contract <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callsInPlace</span><span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">,</span> InvocationKind<span class=\"token punctuation\">.</span>EXACTLY_ONCE<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 함수를 보면 <code>run</code>은 함수 인자로 확장 함수가 들어가는 반면, <code>also</code>는 함수 인자로 함수가 들어간다. 여기서 알 수 있듯이 확장 함수는 수신 객체를 <code>this</code>로 호출하거나 생략이 가능하다. 그래서 이런 차이가 발생하는 것이다. 그러면 이제 설명을 안 한 <code>with</code> 함수에 대해 살펴보자. <code>with</code>은 확장 함수는 아니고 함수이다. 그리고 함수다 보니, <code>this</code>를 사용해 수신 객체에 접근한다. 코드를 통해 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> person <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">with</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>언제 어떤 scope function을 사용해야 할까?</h3>\n<p>그럼 언제 어느 상황에 어느 scope function을 사용해야 할까? 먼저 <code>let</code>을 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> strings <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"APPLE\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"BANANA\"</span></span><span class=\"token punctuation\">)</span>\n    strings<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>length <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">></span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">let</span><span class=\"token punctuation\">(</span><span class=\"token operator\">::</span>println<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>let</code>은 위와 같이 하나 이상의 함수를 call chain 결과로 호출 할 때 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> str<span class=\"token operator\">:</span> String<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"abc\"</span></span>\n<span class=\"token keyword\">val</span> length <span class=\"token operator\">=</span> str<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">uppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    it<span class=\"token punctuation\">.</span>length\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한, non-null 값에 대해서만 code block을 사용하는 경우에 <code>let</code>을 사용하며 이 경우가 가장 많이 사용되는 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> numbers <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"one\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"two\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"three\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"four\"</span></span><span class=\"token punctuation\">)</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">first</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span> firstItem <span class=\"token operator\">-></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstItem<span class=\"token punctuation\">.</span>length <span class=\"token operator\">>=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> firstItem <span class=\"token keyword\">else</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"!</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">firstItem</span></span><span class=\"token string\">!\"</span></span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">uppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한, 일회성으로 제한된 영역에 지역 변수를 만들 때 사용하지만 요런 경우는 보통 private method를 만들어서 풀기는 해서 이런 케이스는 필자같은 경우는 잘 사용하지 않았던 것 같다.</p>\n<p>다음은 <code>run</code> 함수를 언제 사용할 지를 살펴보자. <code>run</code> 함수를 사용할 때 대표적인 케이스로 <strong>객체 초기화와 반환 값의 계산을 동시에 해야할 때</strong> 사용한다. 대표적으로 아래와 같이 객체를 만들어 DB에 바로 저장하고, 그 인스턴스를 활용할 때 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> person <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"양성빈\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>personRepository<span class=\"token operator\">::</span>save<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만, 이런 경우도 잘 사용하지는 않는다. 필자는 자바로 개발을 시작했고, 아래와 같이 작성하는게 익숙하다. 또한, 반복되는 생성 후처리는 생성자, 프로퍼티, init block으로 넣는 것을 추천한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> person <span class=\"token operator\">=</span> personRepository<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"양성빈\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>다음으로 <code>apply</code> 함수를 살펴보자. <code>apply</code>는 객체 그 자체가 반환되며, 객체 설정을 할 때 객체를 수정하는 로직이 call chain 중간에 필요할 때 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    age<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    hobby<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Person <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>\n        name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">,</span>\n        age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hobby <span class=\"token operator\">=</span> hobby\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 test fixture를 만들 때 제일 많이 사용하며, 필자 회사도 이렇게 fixture 함수를 만들 때 사용된다.</p>\n<p>다음으로, <code>also</code> 함수를 알아보자. <code>also</code> 함수도 객체 그 자체가 반환되며, 객체를 수정하는 로직이 call chain 중간에 필요할 때 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token function\">mutableListOf</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"one\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"two\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"three\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">also</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"The list elements before adding new one: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"four\"</span></span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>마지막으로 <code>with</code> 함수에 대해 살펴보자. <code>with</code> 함수는 특정 객체를 다른 객체로 변환해야 하는데, 모듈간의 의존성에 의해 정적 팩토리 혹은 toClass 함수를 만들기 어려울 때 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">return</span> <span class=\"token function\">with</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">PersonDto</span><span class=\"token punctuation\">(</span>\n        name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">,</span>\n        age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code>this</code>를 생략할 수 있어서 필드가 많아도 간결해지는 장점이 존재한다.</p>\n<h3>scope function 가독성</h3>\n<p>scope function을 사용하는 코드가 그렇지 않은 코드보다 가독성이 좋은 것일까? 이펙티브 코틀린에서 이런 문제를 다루는데 아래 코드를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token comment\">// 1번 코드</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>person <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> person<span class=\"token punctuation\">.</span>isAdult<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    view<span class=\"token punctuation\">.</span><span class=\"token function\">showPerson</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    view<span class=\"token punctuation\">.</span><span class=\"token function\">showError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 2번 코드</span>\nperson<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">takeIf</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>isAdult <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span><span class=\"token punctuation\">(</span>view<span class=\"token operator\">::</span>showPerson<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">?:</span> view<span class=\"token punctuation\">.</span><span class=\"token function\">showError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자는 1번 코드가 더 가독성이 좋았다. 왜냐하면 자바에 익숙하기도 했고 딱 보이기 때문이다. 하지만 2번은 간결은 하지만 생각해야할 것이 많다.  구현 2번은 숙력된 코틀린 개발자만 더 알아보기 쉽지만 그 외에는 어려울 것이다. 그리고 1번 코드는 디버깅이 쉽지만 2번은 어려울 것이다. 또한, 2번코드에는 사이드 이펙트가 있다. 만약 let이 null이라고 한다면 view::showPerson을 수행하고 null을 반환한다. 그러면 엘비스 연산자로 showError()가 호출된다. 또한, 구현1번은 유지보수도 쉽다.</p>\n<p>사용빈도가 적은 관용구는 코드를 더. 복잡하게 만들고 이런 관용구들을 한 문장 내에서 조합해 사용하면 복잡성이 훨씬 증가한다. 하지만 scope function을 사용하면 안되는 것도 아니다! 적절한 convention을 적용하면 유용하게 활용할 수 있다.</p>","fields":{"slug":"/java-to-kotlin-starter-guide-추가적으로-알아두어야-할-코틀린-특성/"},"timeToRead":8,"frontmatter":{"title":"[코틀린 입문] 추가적으로 알아두어야 할 코틀린 특성","tags":["kotlin"],"date":"2025-10-08T21:21:27.000Z","image":{"publicURL":"/static/619e6175d83cd70c239721219e3cbc91/banner.png"},"series":"코틀린 입문"}}},"pageContext":{"id":"9feb3248-2bdc-5b3d-8615-93c9a0efa9ea"}},
    "staticQueryHashes": ["2580406332","3810308631"]}